8.1 Background processing

	Human68k ver.2.0 supports "background processing" that can execute multiple user programs in parallel.
	
	With this function, X68000 can be operated as a network file server, or processing such 
	as controlling ADPCM or TV at a specified time like the TIMER command can be done under the control of Human68k.
	This section provides an overview of background processing.
	A background processing program is created by combining the DOS calls described here.
   
8.1.1 What is a process?

	Programs that run under the control of Human68k are called "processes". When Human68k loads a 
	program file stored in an external storage device (such as a floppy disk) into memory, it becomes a process.
  
	Each process has an environment independent of other processes.
	A process is incremented by one each time it executes the DOS call exec($ff4b).
  
	At this time, the process that executed exec($ff4b) is called the parent process, 
	and the process that is loaded from disk to memory and executed by exec($ff4b) is called the child process.

	In other words, if you run an application from COMMAND.X, COMMAND.X is called the parent 
	process and the application is called the child process.

	Although it is possible to have multiple processes in memory at the same time, until now Human68k 
	did not have the ability to run each process in parallel.

	However, from Human68k ver.2.0, each process can be executed in parallel by using "thread" which will be explained next.
  
8.1.2 What is a thread?

	A thread is a flow of control as a program executes in memory.
	Each program running in parallel is a thread. In reality, the CPU can only execute one instruction at a time, 
	so Human68k switches the execution of each thread at high speed to make it appear to be executed in parallel
	(see the figure below).

		Thread 1 →‥‥‥‥→‥‥‥‥→
		Thread 2 ‥‥→‥‥‥‥→‥‥‥
		Thread 3 ‥‥‥‥→‥‥‥‥→‥
		────────────────→
		Time → indicates that the thread is running.

	One process can be divided into multiple threads and executed in parallel, but normally one process should be assigned as one thread. 
	Because if you run multiple threads from a single process, if any one thread changes the environment, it will change the environment of the other threads as well.
	Threads are registered with the system by executing the DOS call open_pr($fff8). The number of threads increases by one each time open_pr($fff8) is executed.
  
8.1.3 Thread State

	Thread states include the active state, which is a running state, and the sleep state, which is a waiting state.
	When a thread does not need to do anything until another thread asks it to do so, it waits by going to sleep.
	By doing so, it will not consume extra execution time, and the overall execution speed will not be slowed down.
	The DOS call for that is sleep_pr($fffc).
	With this DOS call, you can specify the sleep time.
  
8.1.4 Inter-thread communication

	When information is passed between multiple threads, if information is written or read in a chaotic manner, 
	multiple writes may collide, or reading may occur in the middle of writing, resulting in incorrect information passing.
	For this purpose, DOS calls are provided for passing information (communication).
	That is the DOS call send_pr($fffd).
	In addition to communicating information, this DOS call can also activate a sleeping thread.
	You can also use the common area to communicate between threads. This is explained in "8.2 Common Area".
  
8.1.5 Thread distinction

	Each of the multiple threads is assigned a unique ID and program name.
	This ID or name specifies which thread communicates information to which thread.
	Therefore, it is necessary to obtain the ID and/or name of each thread.
	The DOS call for that is get_pr($fffa).
	You can also get detailed information about each thread with this DOS call.
  
8.1.6 Parallel processing and right of execution

	Parallel processing refers to processing as if programs are being executed at the same time by switching the execution of threads at regular time intervals.
	A thread that has been executing for a certain period of time is said to have execution rights.
	At this time, if a certain thread is in the supervisor state, the thread will not switch unless a DOS call is made (such a state is called "execution occupancy").
	In such a case, the processing of other threads will stagnate, so the right to execute must be relinquished at regular intervals to prevent this.
	The DOS call for that is change_pr($ffff).
  
8.1.7 Abandon Thread

	Certain threads may be unnecessary for some reason during parallel processing.
	Also, when a process terminates, it must destroy all threads created by that process.
	The DOS call for that is kill_pr($fff9).
	When destroying threads, don't destroy threads chaotically.
	Chaotic discards can cause unrecoverable and fatal system anomalies. To destroy a thread other than your own, send a destruction request to the thread you want to destroy.
	It then promptly relinquishes execution and hands it over to the thread it wants to destroy.
	A thread that receives a destroy request will destroy according to the request if it is acceptable.
	If the request is unacceptable, it abandons the request and then relinquishes execution.
	After that, when execution right is returned to the thread that issued the request, get_pr($fffa) is attempted to obtain detailed information of the requested thread.
	A successful get indicates that it could not be discarded.
	A failure indicates that it could be discarded.
	If you want to destroy your own thread, first enter an endless loop and wait until another thread activates it. Destroy the thread as soon as it is activated.
	Other threads communicate periodically, as any thread may be in a waiting state as above.
	And at this time, if the communication fails, we know that the thread has destroyed itself.
 
8.1.8 Environmental competition

	Multithreading means that multiple threads are running in a single process.
	In a multithreaded execution state, all threads execute in the same environment.
	Running in the same environment means that the processes are identical, running in the same environment for memory, DOS error handling, and everything else.
	Therefore, do not allocate memory in multiple threads, exit with the DOS call exit($ff00), or exit with CTRL-C or a DOS error abort while leaving other threads. It means that it will not.
	In the standard state, it ends with CTRL-C or DOS error abort processing, so it is necessary to handle those processing in each process.

8.1.9 Environmental competition

	For input/output devices such as files, screens, and keyboards, it is necessary to prevent contention in each thread.
	To prevent file resource contention, DOS calls are provided for file sharing and file locking.
	Be careful not to contend with threads for the screen and keyboard.
	Regarding memory resources, each thread operates under the same memory management. Do not allocate, free, etc,
	memory chaotically unless you use DOS calls to partition memory management on a per-thread basis.

8.1.10 Starting a child process

	If a thread executes a child process, immediately after returning from the child process, give up the execution right once.
	This lets other threads know about it.
   
8.2 Common Area

	There are several ways to pass data between a parent process and a child process, or between two child processes.
	for example,

		- Set parameters in the command line passed to the child process
		- Set up a common environment area for the parent process and the child process
		- Securing a shared memory area in the user program for communication

	However, such methods have the following drawbacks.

		- It is difficult for processes to communicate with each other
		- The format and size of exchanged data are limited.
		- The burden on the user program is large.

	Human68k ver.2.0 supports the exchange of data between processes at the OS level.
	By calling a DOS call from the user program, the OS reserves a memory area called "common area" that 
	is shared between processes, and performs exclusive control when it is accessed.
	The common area can be used not only between processes but also between threads.

8.2.1 Functions of Common Area

	The common area has the following functions.

		- Securing and deleting common areas
		- Reading/writing data to/from the common area
		- Locking and unlocking common areas

	When you reserve a common area, give it a name.
	When accessing or locking, specify the name given to the common area. In addition to the name, it also specifies the part to be accessed or locked. 
	In other words, it is possible to say, "Read only ?? bytes from ?? bytes from the beginning of the common area named ????".
	Multiple common areas can be provided, and the upper limit depends on the memory capacity.

8.2.2 How to use the common area

	To use the common area, use the DOS call common($ff85).
	See the DOS call common section of this manual for the following explanation.

	(1) Securing common areas
		common(2,NAME,POS,BUFFER,LEN)
			NAME : Name given to the newly secured common area
			POS : Position from the beginning to write the data to be initialized
			BUFFER : Address where the data to be initialized is stored
			LEN : Number of bytes of data to initialize
		The return value is the number of bytes of data actually written, or an error code.

	(2) Search common areas
		common(0,NAME)
			NAME : Name of common area to search
		The return value is the number of bytes in the common area if found, or an error if not found.
		
		la code

	(3) Read from common area
		common(1,NAME,POS,BUFFER,LEN)
			NAME : the name of the target common area
			POS : Position from the beginning of the data to read
			BUFFER : Address to store read data
			LEN : Number of bytes of data to read
		The return value is the number of bytes of data actually read or an error code.

	(4) Writing to common area
		common(2,NAME,POS,BUFFER,LEN)
			NAME : the name of the target common area
			POS : Position from the beginning of the data to be written
			BUFFER : Address where the data to be written is stored
			LEN : Number of bytes of data to write
		The return value is the number of bytes of data actually written, or an error code.

	(5) Lock common area
		common(3,NAME,POS,ID_PSP,LEN)
			NAME : the name of the target common area
			POS : Position from the beginning of the area to be locked
			ID_PSP : ID assigned when locking
			LEN : Number of bytes in the locked area
		
		Return value is error code
		Note: Locking prevents access by anyone but the process or thread with ID_PSP.

	(6) Unlock the common area
		common(4,NAME,POS,ID_PSP,LEN)
			NAME : the name of the target common area
			POS : Position from the beginning of the unlocked area
			ID_PSP : ID assigned when locking
			LEN : Number of bytes in the unlocked area
		Return value is error code

	(7) Delete common area
		common(5,NAME)
		NAME : the name of the target common area
	Return value is error code
  
8.3 File sharing and file locking

	One thing to be aware of when multiple threads run in parallel is the handling of files.
	For example, one thread might open a file for writing while another thread opens and accesses the file.
	Therefore, in Human68k ver.2.0, we added a new function called "file sharing".
	File sharing is a feature that allows sharing of files.
	Also, when opening a file, a function called file locking that prohibits access from others has been added.
	These functions have made it possible to implement a network environment.


8.3.1 How to use file sharing

	Specify sharing when opening a file.
	To open a file, use the DOS call open($ff3d).
	See the DOS call open section of this manual for the following explanation.

	open(NAMEPTR,MD)
	
	NAMEPTR : Pointer to string (file name)
	MD: Bits 6-4 = Set sharing mode
	000 = compatibility mode
	001 = disable both read/write
	010 = write protected
	011 = read prohibited
	100 = allowed
	Bits 1-0 = read/write designation
	00 = open in read mode
	01 = Write 〃
	10 = open in read/write mode
	The return value is the file handle of the opened file or an error code

8.3.2 How to use file locking

	File locking uses the DOS call lock($ff8c).
	lock(MD,FILENO,OFFSET,LEN)
		MD :1 = file lock
			0 = 〃 release
		FILENO : File handle of file to lock
		OFFSET : offset from the beginning of the part to be locked
		LEN ;number of bytes to lock

8.4 Overlay X files and binding

	Human68k ver.2.0 supports executable files called "overlay X files".
	An overlay X file is a collection of multiple X format executable files in one file.
	Human68k ver.2.0 can load and execute any X format executable file in this overlay X file into memory.
	Overlay X files are used when the program or data size is too large for the available memory capacity.
	One way to manage a program that is too large to run due to lack of memory is to divide the program.
	For example, a program can be divided into one main program and multiple subprograms, stored on disk, and when executing, only the necessary programs are loaded into memory and executed each time. I have.
	However, in this case, the main program must control the loading, execution, and termination of subprograms, and pass data between subprograms, making programming difficult.
	The overlay X-file and the BIND command described below assist the execution of programs divided in this way.


8.4.1 Creating an overlay X file

	To create an overlay X-file, use the command BIND.
	The format of BIND is as follows.

	BIND [/O] <overlay X file name> <file name> [<file name> …] [/D|/X|/L] [/T<pathname>]

	Items enclosed in '[' and ']' can be omitted.
	You can select one of the items separated by '{'.
	The /O switch is used to create a new overlay X-file. for example,

	BIND /O sample.x sample1.x sample2.x sample3.x, the overlay X file that combines sample1.x sample2.x sample3.x
	sample.x is created.
	
	To add an X format executable file to an existing overlay X file, execute as follows.

	BIND sample.x sample4.x sample5.x

	Other switches have the following functions:

	- /D switch: deletes the specified file from the overlay X file
	- /L switch: display the file names contained in the overlay X file
	- /X switch: extracts the specified file from the overlay X file
	- /T switch: create a temporary file in the specified path

8.4.2 Executing Programs Contained in Overlay X-Files

	Each file included in the overlay X file is given a module number. 
	Specify this module number to select a file in the overlay X file. 
	The module number is assigned from 0 in the order added to the overlay X file.
	In the previous BOND command example,

	The module number of
		sample1.x is 0
		sample2.x 〃 1
		sample3.x 〃 2
		sample4.x 〃 3
		sample5.x 〃 4

	becomes.
  
	When the overlay X file "sample.x" is executed from the command 
	processor (command.x), the module number 0 "sample1.x" is loaded and executed first.
  
	In addition, the normal X format executable file has a module number of 0, 
	so it will be loaded and executed as is.
  
	Files with module numbers other than 0, such as "sample2.x" and "sample3.x", cannot be 
	directly executed from the command processor. In other words, the file with 
	module number 0 operates as the main program, and only when files with module 
	numbers other than 0 are required as subprograms are called from the main program.
  
	Therefore, "sample1.x" with module number 0 functions as the main program, 
	and subprograms such as "sample2.x" and "sample3.x" must be loaded and executed.
  
	The DOS call for that is exec($ff4b) (see the exec section of the DOS call description in this manual). 
	Specify the module number in the MD parameter of this exec.
	The meaning of MD is as follows.

	15 to 8 bits: module number (0 to 255)

	7 to 0 bits: control code
		0: load and run
		1: load only
		2: Find command path
		3: special load
		4: Execute only
		5: get the module number

	Therefore, to load and execute "sample2.x" from "sample1.x", call exec($ff4b) with MD = $0100.
	Also, since the module number can be obtained from the file name, "sample1.x" will 
	run subprograms such as "sample2.x" and "sample3.x" without knowing the module number of those programs. You can.
  
  
8.5 Explanation of sample program

  Here, we use the sample program hide.x to explain how to create a program that uses background processing.
  This program uses the following functions newly added in Human68k ver.2.0.

	- File sharing Exclusive control of files
	- Common area Shared storage area between processes and threads
	- Background processing Parallel processing close to multitasking
	- Creation of bind overlay X file


8.5.1 Functions and operating environment

・Function of "hide.x"

format)
   Set:hide [filename] Unlock:hide [password]

  When you enter the file name, you will be asked for the password and time, so enter them according to the instructions.
  To unlock it, enter the password you specified when you set it up.

function)
     Lock the file until the specified time.
     A lock prohibits access to a file, making it impossible to open the file.
     A reset will unlock it.

・How to create "hide.x"

List 1 is the makefile "makefile" for creating "hide.x".
Please check the following when executing.

・hidem.s and hidesp.s exist in the current directory
- The version of the assembler (AS.X) or linker (LK.X) is 2.00 or later.

Source files "hidem.s" and "hidesp.s" are assembled and linked to create executable files "hidem.x" and "hidesp.x".
"hide.x" is a file that binds "hidem.x" and "hidesp.x".
When running it will run the overlay "hide.x".

・System environment settings

To run this program, you need to make the following settings in "CONFIG.SYS".

(1) Specifying file sharing and exclusive control

SHARE = ​​<number of files> <number of lock areas> [Example] SHARE = ​​10 4

Specify the number of files to be exclusively controlled (locked) and the number of areas to be locked.
If you don't set this, you won't be able to lock the file.

(2) Specification of memory capacity used by DOS call common($ff85)

COMMON = <capacity> [Example] COMMON = 32K

Specifies the amount of memory used by the DOS call common($ff85).
common($ff85) is a DOS call to use a common area shared between processes or threads.
If this is not set, common($ff85) is not available and calling it will result in an error.

(3) Setting control information for parallel processing

PROCESS = <number of programs> <level> <time slice value> [Example] PROCESS = 10 2 10

For <number of programs>, specify the number of programs to be executed in parallel within the range of 2 to 32.
For <level>, specify a value between 2 and 255 that determines the program execution interval.
The smaller the value, the shorter the execution interval, so the execution speed will be faster.
Also, for <time slice value>, specify the execution time of each program in the range of 1 to 100ms.
Parallel processing is not possible unless PROCESS is specified.

・File sharing (list 3, lines 134-143)

Sharing is a function that enables the user who first opens a file to control access to the file by other users.
Specifically, the open mode of the DOS call open($ff3d) has been extended to allow control over whether or not to read or write duplicate files.
This program demonstrates using the sharing mode $1? to eliminate duplicate accesses.

・Common area (list 3, lines 91-99, 197-202)

The common area is reserved in the Human68k system area and is a storage area shared by processes or threads.
For example, it can be said to be a message board for processes and threads.
Processes and threads can access the common area by using the DOS call common($ff85).
This program writes file handles and passwords to Comoneria.

・Background processing

Background processing has a function close to multitasking that apparently executes multiple programs in parallel.
However, there are restrictions such as threads cannot use the system at the same time.
The following two points should be noted when actually creating a background program.

(1) It is necessary to create the same number of programs (processes) as the number of threads.

It is possible to perform background processing even with a single program, but when the thread switches, the environment (CTRL-C set in the process management area, OS error abort processing destination, etc.) should also switch.
Otherwise, each thread will share the environment, and if one thread modifies the environment, etc., it will affect other threads.
However, in the same process, Human68k can only have one process management information per process.
So to actually switch them for each thread you have to run each thread as a separate child process and change the environment at the beginning of the thread.

(2) Programs that perform background processing must be resident programs.

A normal program is removed from memory when the program terminates.
However, a resident program leaves part of it in memory even after the program terminates, and is called later in some way to do processing.
A background program consists of two programs, a parent process and a child process, and the child process is a resident program.
In the sample program, the parent process is "hidem.s" and the child process is "hidesp.s".
  
8.5.2 Parent Process (Listing 2: hidem.s)

  The parent process does two things.

・If there is no thread, execute a child process to create a thread.
・If there is a thread, a discard request is made through inter-thread communication.

The parent process has the following structure:

(1) Check the version of DOS (lines 85 to 92) The executable DOS version is 2.00 to 2.49.
Use the DOS call vernum($ff30).

(2) Check for thread existence (lines 119-131) If a thread already exists, branch at (7), otherwise proceed to (3).
Here we use the DOS call get_pr($fffa).

(3) Execute the child process (lines 17, 21-31) Use the DOS call exec($ff4b) here.
The sample executes the process in the overlay file.
The child process keeps its background processing part resident in memory in a sleeping state.

(4) Communicate the command ($fffb) to activate the thread because the thread is in permanent sleep state (lines 62-67, 104-118)
Here, communication is performed using the DOS call send_pr($fffd).

(5) End (20 lines)

(6) Get the ID numbers of yourself and the thread as communication parameters (lines 119 to 131) Here, the DOS call get_pr($fffa) is used.

(7) Communicate a thread destruction request ($fff9) to the thread (lines 65-77)
Here, send_pr($fffd) is used for communication.
However, in the sample program, we let the thread self-destruct instead of requesting it to be destroyed.

(8) End (lines 19-20)


8.5.3 Child Process (Listing 3: hidesp.s)

  The child process is divided into two parts. A resident part that performs background processing and a non-resident part that creates and terminates threads.
  The background processing part is placed in the front, and the thread creation and resident termination parts are placed in the back. And the back part is run as a child process from the parent process and truncated when exiting the resident.

  The resident section performs the following functions.

	・Environment settings
	・Receive inter-thread communication
	・Destruction of thread
	・Background processing

  The non-resident department performs the following functions.

	・Create a new thread
	・Memory resident background processing

  The resident part looks like this:

(1) Environment settings (lines 14 to 15, 39 to 49) Change the processing destination of CTRL-C and error abort when the thread is switched.
  Here we use the DOS call intvcs($ff25).

(2) Receiving communication between threads (lines 16 to 38) When communication comes from another thread, the necessary information is stored in the communication buffer. 
  Also, if it was in sleep mode, it will be activated.
  Read commands and data from the inter-thread communication buffer and branch to the corresponding processing program.
  See the DOS call open_pr($fff8) for the contents of the communication buffer, and sleep_pr($fffc) for the procedure for reading from the communication buffer.
  At the end of this part, we put the thread to sleep with the DOS call sleep_pr($fffc). This is to reduce the work of the thread and not slow down the entire system by not using all of its allotted time. Make sure to sleep if there is nothing to process until the next request is made.

(3) Abandon thread (line 03) Use the DOS call kill_pr($fff9) here.
  When receiving a discard request command ($fff9) in inter-thread communication, the thread will discard according to the request if it is an acceptable request. If the request is not accepted, discard the request and then relinquish the execution right.
  After that, when the execution right is returned to the thread that issued the request, the DOS call get_pr($fffa) is attempted to obtain the detailed information of the requested thread. A successful get indicates that it could not be discarded. A failure indicates that it could be discarded.
  If you want to destroy your own thread, first go to sleep forever and wait until another thread activates it. Other threads communicate periodically, as any thread may be in a waiting state as above. And at this time, if the communication fails, the thread knows that it has destroyed itself.
  When destroying threads, don't destroy threads chaotically. Chaotic discards can cause irreversible and catastrophic system failures.

(4) Main body of background processing (lines 53 to 101) Here, the user can create any program.
  However, there are restrictions, so please refer to the notes below.

  The above is the main background processing and resides in memory.
  Next, I will explain the temporary part.

(5) Creating a new thread (lines 203-216) Here, the DOS call open_pr($fff8) is used.

(6) Resident termination (lines 217-221)
  Here we use the DOS call keeppr($ff31).
  The resident program range varies depending on the location of background processing data, work, and stack area.
  Putting them at the end of the child process means that the whole program has to be resident. However, since this part is essentially a non-resident part, the data, work, and stack areas are placed just above this, that is, at the end of background processing, as in this program. Then, the resident size is small because the resident range can be up to that point.
  At this time, please note that data, stack, etc. should also be placed in the text section (.text). Therefore, be careful not to write section pseudo-instructions such as .data, .bss, and .stack there.
  
	parent process 														child process
┌───────────────────────────────────────────────────────────┐┌──────────────────────────────────────────────┐
│ 				 							  				││─ Resident Department ─         			  	│
│ 				 							  				││ 							   				  	│
│ 				 							  				││Resides in memory and performs 			  	│
│1.When there are no threads, it runs the non-resident  	││	background processing 					  	│
│ part of the child process and communicates to activate	││  											│ 
│ the resident part of the forever sleep state. 			││When writing data here, do not put .data 	  	│
│ 											  				││ 	.bss, .stack							  	│
│ 											  				│├──────────────────────────────────────────────┤
│2. Communicate a discard request to the   					││─ non-resident section ─ 						│
│ resident part when there is a thread						││Create a resident part as a thread and		│
│ 															││  terminate it permanently					│
│ 															││ 												│
│ 															││This part is not stored in memory				│
└───────────────────────────────────────────────────────────┘└──────────────────────────────────────────────┘

8.5.4 Precautions for programming

・If you set the execution address in the middle of the program in the child process, if you write her label after the .end pseudo-instruction, execution will start from that label.
- Background processing cannot be traced by the debugger (DB.X).
  An incomplete program running as a thread is difficult to stop and can even crash the system.
  Therefore, during development, separate the resident and non-resident sections and debug them thoroughly until they run perfectly.
- As mentioned above, you need several programs in the background. Therefore, the BIND command is used to combine them into a single program.
  The advantages of using the BIND command are:
(1) Convenient handling as it can be handled as a single file
(2) There is no fear that the file name of the child process will be changed
(3) When executing the child process, it uses its own bind file name, so it can be executed regardless of the file name change.
(4) Routine to check the initial environment such as DOS version Only the first program is enough.

  When creating a background processing program, be sure to make it a single file with the BIND command.


8.5.5 Sample program list

Listing 1; makefile
────────────────────────────────────────────────────
hide.x: hidem.x hidesp.x
		bind /o hide.x hidem.x hidesp.x
hidem.x: hidem.s
		as hidem.s
		lk hidem.o
hidesp.x: hidesp.s
		as hidesp.s
		lk hidesp.o

Listing 2; hidem.s
────────────────────────────────────────────────────
001		*---------------------------------------------------------
002		*	Manual sample parent process (hidem.s)
003		*	Runs once at the beginning and becomes the parent process of the background process
004		*	Also runs when sending a password to stop the thread
005		*
006		*---------------------------------------------------------
007			.include		doscall.mac
008			.text
009			.even
010		start:
011					lea		stkptr,sp			* user stack setting
012					bsr		version_chk			* DOS version check
013					bsr		cl_cpy				* copy commandline
014					bsr		get_id				* Are there threads?
015					tst		d0
016					bmi		exec_pr				* if not, run child process
017					bra		pw_send				* if thre is, pass the password to the thread
018		exit_ok:
019					DOS		_EXIT
020		exec_pr:						* child process execution
021					bsr		m_free
022					bsr		psp_read			* copy of your file name
023					clr.l	-(sp)				* environment
024					pea		cl_buff				* command line
025					pea		(a0)				* child process file name
026					move.w	d1, -(sp)			* mode
027					DOS		_EXEC
028					lea		14(sp),sp
029					bsr		exec_chk
030					bra		act_pr
031		m_free:							* free memory behind parent process
032					lea		start-$100,a0
033					lea		start-$100+$38,a1
035					lea		$10(a0),a0
035					move.l	(a1),a1
036					sub.l	a0,a1
037					move.l	a1,-(sp)
038					move.l	a0,-(sp)
039					DOS		_SETBLOCK
040					addq.l	#8,sp
041		psp_read:						* copy filename from PSP
042					move.b	start-$100+$60,d1
043					add.b	#1,d1
044					asl.w	#8,d1
045					clr.b	d1
046					lea		team_work,a1
047					lea		start-$100+$80,a2
048					bsr		str_cpy
049					lea		start-$100+$c4,a2
050					bsr		str_cpy
051					lea		team_work,a0
052					rts
053		exec_chk:
054					cmp.l	#$10000,d0
055					blt		exec_err
056					bsr		get_id				* get thread id
057					tst		d0
058					bmi		nf_err
059					rts
060		act_pr:
061					move.l	#0,d5
062					move.w	#$fffb,d6			* active thread
063					bsr		send_cmd
064					tst		d0
065					bmi		send_err
066					bra		exit_ok
067		pw_send:
068					cmp.b	#4,(a3)				* is the command line 4 characters?
069					bne		thd_err
070					addq.l	#1,a3
071					bsr		num_chk				* Is the commandline a number?
072					move.l	#4,d5				* Send the password to the thread
073					move.w	#$1000,d6
074					bsr		send_cmd
075					DOS		_CHANGE_PR
076					move.l	#0,d5				* Send password to thread
077					move.w	#$1000,d6
078					bsr		send_cmd
079					tst.l	d0
080					bpl		send_err
081					bra		end_msg
082		* Common subrutine
083		version_chk:
084					DOS		_VERNUM				* Get DOS version
085					cmp.w	#$200,d0			* Error before version 1.99
086					blt		ver_err
087					cmp.w	#$231,d0			* Version 2.50 and above
088					bhi		ver_err				* 2.50 is judget to be equivalent to 3.00
089					clr.l	d0					* Others are recognized as 2.00
090					rts
091		cl_cpy:						* copy command line
092					move.l	start-$100+$20,a2
093					move.l	a2,a3
094					cmp.b	#0,(a2)
095					beq		use_disp
096					lea		cl_buff,a1
097		str_cpy:						* string copy
098					move.b	(a2)+,(a1)+
099					tst.b	(a2)
100					bne		str_cpy
101					rts
102		send_wait:
103					DOS		_CHANGE_PR
104		send_cmd:
105					move.l	d5,-(sp)			* send command to thread
106					lea		cl_buff,a0
107					addq.l	#1,a0
108					move.l	a0,-(sp)
109					move.w	d6,-(sp)
110					move.w	thd_id,-(sp)
111					move.w	my_id,-(sp)
112					DOS		_SEND_PR
113					lea		14(sp),sp
114					cmp.l	#-28,d0
115					beq		send_wait
116					rts
117		get_id:							* Subrutine for ID
118					pea		my_tbl				* Find my ID
119					move.w	#-2,-(sp)
120					DOS		_GET_PR
121					addq.l	#6,sp
122					move.w	d0,my_id
123		gets_id:
124					pea		thd_tbl				* get thread ID
125					move.w	#-1,-(sp)
126					DOS		_GET_PR
127					addq.l	#6,sp
128					move.w	d0,thd_id
129					rts
130		num_chk:						* Is it a number?
131					move.w	#3,d4
132		n_cmp:
133					cmp.b	#$30,(a3)
134					blt		thd_err
135					cmp.b	#$39,(a3)+
136					bhi		thd_err
137					dbra	d4,n_cmp
138					rts
139
140		* error messages
141		end_msg:	pea		end_mes
142					bra		err_msg
143		exec_err:	pea		exr_msg
144					bra		err_msg
145		nf_err:     pea     nfr_msg
146					bra     err_msg
147		use_disp:	pea		use_msg
148					bra		err_msg
149		par_err:	pea		par_msg
150					bra		err_msg
151		thd_err:	pea		thd_msg
152					bra		err_msg
153		send_err:	pea		sdr_msg
154					bra		err_msg
155		ver_err		pea		ver_msg
156					bra		err_msg
157		err_msg:	DOS		_PRINT
158					addq.l	#4,sp
159					bra		exit_ok
160					.data
161		end_mes:	dc.b	'File released!',$0d,$0a,0
162		nfr_msg:	dc.b	'Failed to register file',$0d,$0a,0
163		exr_msg:	dc.b	'execute child process',$0d,$0a,0
164		use_msg:	dc.b	'Usage hide [filename]',$0d,$0a
165					dc.b	'Prohibits access to files until an arbitrary time.',$0d,$0a
166					dc.b	'You will be asked for to enter'
167					dc.b	'a password and time',$0d,$0a
168					dc.b	'to unlock the command, follow the password'
169					dc.b	'Please enter',$0d,$0a,$0d,$0a
170					dc.b	'>hide XXXX (X is a half-width number)',$0d,$0a,$0d,$0a,0
171		thd_msg:	dc.b	'The file is already registered',$0d,$0a,0
172		sdr_msg:	dc.b	'communicate',$0d,$0a,0
173		par_msg:	dc.b	'Wrong parameters',$0d,$0a,0
174		ver_msg:	dc.b	'The DOS version is different',$0d,$0a,0
175		crlf:		dc.b	$0d,$0a,0
176		team_work:	ds.b	50
177		cl_buff:	ds.b	16			* commandline buffer
178		my_id:		even
179					dc.w	-1			* my ID
180		thd_id:		dc.w	-1			* Thread ID
181		my_tbl		ds.b	116			* my management table
182		thd_tbl:	ds.b	96			* Thread management table
183					dc.b	'NEWZ',0	* Thread name
184					even
185					dc.l	0
186					ds.l	1024
187		stkptr:
188					.end	start

			

Listing 3; hidesp.s
────────────────────────────────────────────────────
001		*----------------------------------------------------------
002		*
003		*	Background processing sample		child process (hidsp.s)
004		*
005		*	The part from startp to endp is the resident part (background processing body)
006		*	and the rest is the non-resident part that is executed only once.
007		*
008		*-----------------------------------------------------------
009			.include		doscall.mac
010			.text
011			.even
012		* Beginning of resident division
013		startp:
014					move.l	sp,sp_work
015					bsr		vect_set			* change destination of error report
016		send_chk:
017					bsr		time_chk
018					cmp.l	#-1,d0
019					beq		fin
020					lea		mes_buff,a3
021					move.w	10(a3),d1			* Check for communication
022					cmp.w	#-1,d1
023					beq		no_send
024					move.w	8(a3),d2			* Communication command
025					cmp.w	#$1000,d2			* Check receive password command
026					beq		pw_clr
027					cmp.w	#$fff9,d2			* abandon Thread request
028					bne		no_com_send
029		exit:							* abandon Thread
030					DOS		_KILL_PR
031		no_com_send:					* initialize communication buffer
032					move.w	#0,8(a3)
033					move.w	#-1,10(a3)
034		no_send:
035					move.l	#100,-(sp)
036					DOS		_SLEEP_PR			* sleep and wait
037					addq.l	#4,sp
038					bra		send_chk
039		* comment
040		*
041		vect_set:						* Setting the processing destination when importing
042					pea		ctrl_c
043					move.w	#_CTRLVC,-(sp)
044					DOS		_INTVCS
045					addq.l	#6,sp
046					rts
047		ctrl_c:					        * Error abort rutine
048					move.l	sp_work,sp			* current SP for abort temporarily
049					bra		no_send				* give up execution right and go to main
050		*	Handling messages (passwords)
051		time_chk:						* time comparison
052					DOS		_GETTIM2
053					tst		d0
054					bmi		exit
055					move.l	d0,d1
056					clr.w	d0
057					swap	d0
058					cmp.b	hour,d0
059					bne		exit_ts
060					move.l	d1,d0
061					lsr		#8,d0
062					cmp.b	min,d0
063					bne		exit_ts
064					move.l	#-1,d0
065		exit_ts:
066					rts
067		pw_clr:
068					move.w	#1,d0				* Read common area
069					bsr		com_rw
070					lea.l	com_buff,a0
071					lea.l	mes_data,a1
072					addq.l	#2,a0
073					move.l	#3,d1
074		pw_cmp:							* password comparison
075					cmp.b	(a0)+,(a1)+
076					bne		break
077					dbra	d1,pw_cmp
078					sub.l	#6,a0				* file close
079					move.w	(a0),-(sp)
080					DOS		_CLOSE
081					addq.l	#2,sp
082		fin:
083					pea		com_name			* Discard common name
084					move.w	#5,-(sp)
085					DOS		_COMMON
086					addq.l	#6,sp
087					DOS		_CHANGE_PR
088					bra		exit
089		break:
090					bra		no_com_send
091		com_rw:							* Common read/write subrutines
092					move.l	#20,-(sp)
093					pea		com_buff
094					move.l	#0,-(sp)
095					pea		com_name
096					move.w	d0,-(sp)
097					DOS		_COMMON
098					lea		18(sp),sp
099					rts
100		* Thread data
101		*	.data
102		com_name:
103					dc.b	'GT-R',0
104		* Thread work area
105		*	.bss
106		hour		ds.b	1
107		min			ds.b	1
108		sp_work:	even
109					ds.l	1
110		com_buff:	ds.b	20
111		mes_buff:						* inter-thread communication management buffer
112					dc.l	4			*
113					dc.l	mes_data
114					dc.w	0
115					dc.w	-1
116		mes_data:						* actual message
117					ds.b	4
118		*			.stack
119					ds.l	2048		* system stack for threads
120		ssp1:
121					ds.l	512			* user stack for threads
122		usp1:
123		endp:
124		* Temporary from here
125		*	.text
126		main:
127					lea		user,sp
128					lea		com_buff,a0			* Common buffer
129					bsr		fopen				* pointer file open
130					bsr		get_pw				* password input
131					bsr		get_tm				* time input
132					bsr		com_w				* write common area
133					bsr		thred_open			* create new thread
134					bmi		exit_ok
135					bra		keep				* end of residency
136		fopen:
137					move.w	#$0,-(sp)			* Disable file access via sharing
138					addq.l	#1,a2
139					move.l	a2,-(sp)
140					DOS		_OPEN
141					addq.l	#6,sp
142					tst		d0
143					bmi		open_err
144					move.w	d0,(a0)+
145					rts
146		get_pw:
147					lea		pw_msg,a1			* password input
148					bsr		disp
149					move.w	#$39,d3
150					move.w	#3,d1
151		i_pw:
152					bsr		i_num
153					add.b	#$30,d5
154					move.b	d5,(a0)+
155					dbra	d1,i_pw
156					lea		clrf,a1
157					bsr		disp
158					rts
159		get_tm:
160					lea		tm_msg,a1			* time input
161					bsr		disp
162					move.w	#$32,d3
163					bsr		i_num
164					move.b	#$39,d3
165					cmp.b	#2,d5
166					beq		tg13
167					bra		tg12
168		tg13:
169					move.b	#$33,d3
170		tg12:
171					bsr		tg11
172					move.b	d4,hour
173					move.w	#$3a,-(sp)
174					DOS		_PUTCHAR
175					addq.l	#2,sp
176					move.b	#$35,d3
177					bsr		i_num
178					move.b	#$39,d3
179					bsr		tg11
180					move.b	d4,min
181					lea		clrf,a1
182					bsr		disp
183					rts
184		tg11:
185					mulu	#10,d5
186					move.b	d5,d4
187					bsr		i_num
188					add.b	d5,d4
189					rts
190		i_num:
191					DOS		_GETC
192					cmp.b	#$30,d0
193					blt		i_num
194					cmp.b	d3,d0
195					bhi		i_num
196					move.b	d0,d5
197					sub.b	#$30,d5
198					move.w	d0,-(sp)
199					DOS		_PUTCHAR
200					addq.l	#2,sp
201					rts
202		com_w:
203					move.l	#2,d0				* write file handle in common area
204					bsr		com_rw
205					tst		d0
206					bmi		exit_ok
207					rts
208		thred_open:						* spawn a thread
209					clr.l	-(sp)
210					pea		mes_buff
211					pea		startp
212					move.w	#0,-(sp)
213					pea		ssp1
214					pea		usp1
215					move.w	#$10,-(sp)
216					pea		thd_name
217					DOS		_OPEN_PR
218					lea		28(sp),sp
219					tst		d0
220					bmi		exit_ok
221					rts
222		keep:
223					move.l	#endp,a0			* terminate the thread
224					sub.l	#startp,a0
225					move.l	a0,-(sp)
226					DOS		_KEEPPR
227		*
228		exit_ok:
229					DOS		_EXIT
230		open_err:
231					lea		or_msg,a1
232					bsr		disp
233					bra		exit_ok
234		disp:
235					move.l	a1,-(sp)
236					DOS		_PRINT
237					addq.l	#4,sp
238					rts
239					.data
240		clrf:		dc.b	$0d,$0a,0
241		thd_name:	dc.b	'NEWZ',0
242		pw_msg:		dc.b	'Please enter password(XXXX;X single-byte number) >',0
243		tm_msg:		dc.b	'Please enter time(HH:MM; H:hour,M:minute) >',0
244		start_thd:	dc.b	'Denied access',$0d,$0a,0
245		or_msg:		dc.b	'File can not be opened.',$0d,$0a,0
246				.stack
247				ds.l	256
248		user:
249				.end	main			* run from main.
250