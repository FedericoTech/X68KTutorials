
Oh!X_1993-02.pdf 99 - 108

バックグラウンド SB 里

Murata Toshiyuki ネ寸田 敏



先月に 続き， Human68k ver 2.0 の 拡張 機能 を 取り上げます。 
今回 は， いくつかの 処理 を 同時に 行ラ ための バックグラウンド 処 理 機能に ついて 解説し ましよ ラ。 
この 機能 を 使った プログラム を 具体例に， 作成 方法と その 常駐， 実行の やり方 を 考えて みます

今回 は， 複数 プログラムの 並列 実行 を 可能と する ノ 《ック グラウン ド ^理 機能 を 使った プロ グ ラムの 作

り 方 を 中心に， Human68k ver 2.0 の プロセス/ メ モ リ ^现 まわ り の 機能 をみ てい く。 
例によって， 個 々の DOS コールの 呼び出 し 方な ど について は あま り 触れる つも り はない ので， 適宜 『プログラマー ズ マニュアル』 を 参照しても らいたい。

------ バ ッ クグラ ゥ ン ド 処理 機能の 概要  ----------

いうまでもな いこと だが， 複数の プログラム 力- : 並 行して 走る とはいっても， CPU が ひ とつし かない

以上， あ る 瞬間 に 实行 される プログラム は た だ ひ と つ だけ だ。 し 力' し， プログラム を ちょっと 実行して はべつ の プログラム を また ちょっと 実行す る， とい うよう に 制御 を 十分 短い 間隔で 切り替えて やれば， 複数の プロ グラ ム が 並列 動作 している ようにみ える。 こ れが いわ ゆ る マルチ タス キングの 基本 だ。 
一般に， タスク I' の 切 り 替 え は 一定 時間 ご と に' 剖 り 込み を かける タ イマ を 利用して 行われる。 図 1 に その 様子 を 示した。 
横軸に 時間， 縦軸に 実行中の タ スク （概念 上 は プログラム カウンタ） をと つて ある。
左から みても らう と， 最初 は プログラム A が 走って いる。 ここに タイマ 割り込みが かかり， 制御 は 割り 込み ルーチンに 移る。 タスク 切り替え はこの タイマ 割り込み ルーチンが 行う。 

通常の場合， 割り込み ルーチンで は 必要 な 処理が す ん だら 割り込み 発生 時に 実 行中だった プログラムに 戻る わけ だが， 故意に， 戻 り ァ ドレス を 操作して べつの プログラム （図で はプログ ラム B) に 制御 を 移す の だ。 
この 際， 本来 戻る はず だつ た プロ グラ ム A 内の 位置 や 割 り 込みが かかつ た 時点での レジスタ 内容 は どこか に 保存 してお き， つぎに プログラム A の 実行 を 再開す る と き に 元に 戻 • す。 
こう して 割り込み ルーチン 内で レジスタ 内容 を こっそり， かつ， ごつ そり， とっかえひっかえ する こと = タスク 切り替え， となる。 
Human68k のパ ッ ク グラウン に 処理 機能 も ， 基本的 に はこの ような 方 法で 複数 プロ ダラ ム を 並列 実行す る 。

さて， 通りの よさから 便宜上 タスクと いう 言葉 を 使って き た が, Human68k の ノ《 ック グラウン ド処 理 機能で は "ス レツ ド （thread)" が 並列 処理の 管理 単位になる。 
スレッドと は， 何 かひと つながりの も のとい つ た 意味で， い ま の 場合， 逐次 的に 処理 さ れ る プログラムの 命令 列， あるいは， その 処理の 流れ を 指す。 
ft ス レツ ド は ス レ ッ ド ID と 呼ばれ る 番号 とス レツ ド 名 で 識別 される 2 )。 
起動時 に は メイン (ス レツ ド ID 力 ? 0, ス レツ ド名 "Human68k system" ) のス レツ ドカ f ひ と つ 用意 さ れ， フォア グラ ゥ ン ドで 3"')J く プログラム， つまり， COMMAND. X やその 子 プロセス と して 走る 各 プログラム はこの メ インの ス レツ ドに厲 す る"。 
この メイン ス レツ ド だけの 状 態から DOS コール open pr によ り タスク を登錄 すると 新た な スレッドが 生まれて， メインの ス レツ ド と CPU 時間 を 分け合いながら 実行され る こ と になる。 
パッ ク グラウンド タスク はかな ら ず 常駐 プロ グラム として 作成し， open__pr 後， DOS コール keeppr で常 e ^了す る。 
このと き， 必要なら 同じ メモリ ブロック 上に 複数の タスク を 置き， 個 別 に open 一 pr で 登録 してから まとめて 常駐す る こと も 能 だ。 
そ の 場合， 各 タスク は 同一 プロセスと して 環境 を 共有す る こ と にな る。

登録 し たバ ック グラウンド タスク を 破棄す ると き に は， DOS コール kill— pr を 使う。 
kil し pr は それ を 呼び出 した タスク 自 身の 属す るス レツ ド を 破棄 し ， 常駐して 占有して いた メモリ も 解放す る。 
複数 タス ク からなる バック グラウン ド プロセスの 場合， ある タスクが 自殺す ると， 同一 プロセス として 環境 を 共 有する 全 タスク も 道連れになる。 
ここで， km— pr は あ く まで "自殺" する DOS コール だ。 
自分 以外 の スレッド を 破棄す る 直接的な 方法 は 用意され てい ない。 
その 場合 は， スレッド 間 通信に より 破棄 要求 を 送りつ けて 自殺させる と いう 方法 を とる。 
ス レツ ド間 通信に ついては また あとで 触れよ う。

------ レッド 切り替えの 実際  ----------


ス レツ ド 切り替え 用の タイマ と して は MFT のタ イマ D が 使用され る。 
タイマ D の 割り込み を 設定す る IOCS コ一ル TIMERDST は， PROCESS を 設定 した 時点で 無効 化され， 以後， ユーザーから は 利用 不能になる。 
なお， 本来 タイマ D の 割り込み 間隔 は 細か く —設定で き る の だが， 最長に 設定 しても それ を そのまま スレッド 切り替え 間隔 とする に は 短す ぎ る た め， 灾: 際に は 割り込み 間 隔 を 1 ms 固 定 とし， 剖 り 込み ルーチン 側で 割 り 込み 回数 を 数えて 一定 回数 ごとに スレッド を 切り替える ようになつ ている。

割り込み による スレッド 切り替え は， ユーザー モー ド 時に かぎって 行 われる。 これ は DOS コ ールゃ IOCS コールな どの システム コールが リエ ン ト ラン ト （reentrant ： 再 入 可能） になって いない た め だ。 
仮に シ ス テム コールの 処瑰 中で も ス レツ ド 切り替え を 許すとなると， システム コールの 処31 が 終わりに 達しな いう ちに ほかの ス レツ ド から 同じ シス テムコ一 ルカ s 発行され る 可能性が 出て く る わけ だが， DOS コー ルゃ IOCS コール は そのよ う な 呼び出しに は 対応し ていないの だ。 
タイマ 割り込み ルーチン は， 割り込 み 時に スタック に 積 ま れた sr を 調べ る ことで 割り込 み 前に スーパーバイザ モー ド だつ たか ど う か を 確認 し， もしそう だったら システム コール （あるいは ほ かの 割 り 込み ルーチン） の 処理 屮 と 判断 して ス レツ ドを 切り替えずに 戻る。 この 副作用で， スーパー バィザ モー ドで 走る アプリ ケーシ ヨン プログラムの 実 行中 も スレッド' 切り替え は 停止す る。 
そこで， スー パー パイ ザ モー ドで 走る プログラム は， 自発 旳に実行 権 を放糜 して ほかの スレッド に 実行権 を 渡す DOS コール change_pr を 定期的に 呼び出す こ と が 推奨 さ れ ている。


もっとも， タイマ 割り込み ルーチン は スレッド を 切り替え そこねた とき に は 内部の フラグ を 立てて 戻 るよ うにな つてお り， Human68k 本体 は DOS コー ルの 処理が 終わ るた びに その フラ グを 調べ， 必要な ら （割り込み によ ら ずに） ス レツ ドを 切り替えて く れ る。 
このため， スーパーバイザ モードで 走る プロ グ ラムで あっても， 適^な 間隔で DOS コール を 発行 してい れば， ス レツ ド切 り 替え を 完全に 止めて しま うこと はない。 むしろ， 単に 実行権 を 占有して しま わない よ う にす る だけの H 的で あれば， change_pr よ り もダミ 一の DOS コール を 発行 し た ほ う がよ い かも しれない。 
change_pr を 使う と， また' その ス レツ ドが 使つ て いられる 時間が 残つ ていても 無条件に ス レ ッ ド が 切り替わって しまう が, その ほ かの DOS コールな ら時 |!H 切れに なって いた ときに のみ ス レツ ドが切 り f きわる。 
この と き 利用す る DOS コール と し て は， 害が な く， ごく S 期間で 処理が 終わ る も の， た と え ば， curdrv なんかが 適 している だろ う 。

この ほ 力'， ス レツ ド 切り替え は DOS コール 中で キー入力 侍ち になった ときに も 行われる。 
キー入力 な ど， ユーザーの 応答 を 侍って い る あいだ は 最も CPU が 遊んで いる 期 問で あ り， キー入力が ある ま で ほかの ス レツ ド に 実行権 を i' 度す の はごく 自 然だ。 
そもそも （シングル ユーザー 環境での） マルチ タスク の 存在意義 は このよう な 無駄な 時間 を 有効 利) TJ す る ことに ある。 
ここで， IOCS コール B_KEYINP に は このよう な 細工が 施されて いない こ と に 注意 し たい。 キーの 先行 入力がない と き に B_KEYINP を 呼び出 すと， キー入力が あるまで スレッド 切り替えが 停止 してし まう。 
そうしな いために は， B_KEYSNS で キー バッファに データが あるの を 確か めてから B_KEYINP を 呼び出す よ う に しなければ ならない。

さて， スレッド 切り替え は 単純 にス レツ 卜" ID 順 に 行われる わけで はない。 
&ス レツ ドには 実行 優先 レベル" が 与え られ ており， Human68k はこの レべ ルを 考慮して， 実行権 を 渡す ス レツ ドを 決める 5> 。 
実行 優先 レベル は 2 — 255 の 値で 表し， 値が 小さい ほど レベルが 高 く ， それだけ 優先して CPU 時間が 与えられる こと を 意味す る。 
大雑把に いって， 実行 レベルの 値が 半分になる と， 実行権が 渡される 回数 は 倍になる。

ちなみに， Human68k はつぎの よ う な 方法で 優 先 順位つ きの ス レツ ド 切り替え を 実現して いる。  
ず， 各 スレッド ごとに 1 バイ 卜の カウンタ を 用意し， 実行 優先 レベル一 1 の 値で 初期化 してお く。 
ス レツ ド 切り替え 時には， カウンタの 値が 最小の スレ ッ ド を 探す。 
こ の 検索 はい ま ま で 実行 していた ス レツ ドのつ ぎの スレッドから ス レツ ド ID 順に 行 われる。 
カウンタ が 最小の ス レツ ドが 複数 あ つ た 場合 は: t に みっかつ たほう 力 ? 選ばれる。 
こ う してみ つけた スレ ッ ド に 実行権 を 渡す の だが， このと き， その スレッド の カウンタの 残り を ほかの ス レツ ドの カウンタから 引き， 同時に 実行権が 渡 さ れた スレッドの カウンタ を リセット する。 
以下， この 繰り返し だ。 
参考まで に 実行 優先 レベル 3， 4, 6 の 3 スレッドが ある 場 合の カウンタの 変化 を 表 1 に 示して おこう （表 中， 矢印 は カウンタの リ セッ ト を 表す）。


表 1 優先順位 つきの スレッド 切り替え

ス レツ ド A	│	ス レツ ド B	│	ス レツ ド C	│	実行され る 二く レッド
────────────┼───────────────┼───────────────┼─────────────────────
	2		│		3		│		5		│		初期 状態		
	0 → 2	│		1		│		3		│		ス レツ ド A
	1		│		0 → 3	│		2		│		ス レツ ド B
	0 → 2	│		2		│		1		│		ス レツ ド A
	1		│		1		│		0 → 5	│		ス レツ ド C
	0 → 2	│		0		│		4		│		ス レツ ド A
	2		│		0 → 3	│		4		│		ス レツ ド B
	0 → 2  	│		1		│		2		│		ス レツ ド A
	1		│		0 → 3	│		1		│		ス レツ ド B
	0		│		2		│		0 → 5	│		ス レツ ド C
	0 → 2	│		2		│		5		│		ス レツ ド A
	0		│		0 → 3	│		3		│		ス レツ ド B
	0 → 2	│		3		│		3		│		ス レツ ド A
	0 → 2	│		1		│		1		│		ス レツ ド A
	1		│		0 → 3	│		0		│		ス レツ ド B
	1		│		3		│		0 → 5	│		ス レツ ド C




ところで， 实行 優先 レ ベル は open_pr で タスク を 登録す ると きに （メ インス レツ ドの 場合 は CONFIG.SYS の PROCESS 行で) 指定で き る のみで， あと か ら 変更す る 方法が 用意され ていない。 そこで リスト 1 だ。 
たぶん， 今月 唯一の 実用 プログラムだろう。 
引数と して ス レツ HD と 実行 優先 レベル を 指定す る と ， 対応す る Human68k 内部の ス レツ ド管理 情 報 を 直接 書き換えて， 実行 優先 レベル を変疋 する。 アセンブル 時には リ ス 卜 2 も カレン ト ディ レクト リ に 置いて お く。 
リスト 2 はバッ ク グラウン ド^ 係の 構造体/定数の 定義 ファイル であり， あとの プログ ラムで も 共通に 使う。

リス 卜 1 RENICE.X
────────────────────────────────────────────────────────────────────────────────
*			ス レツ ドの 実行 ほ 先 レベル を 変^す 
			.include		doscall.mac
			.include		ioscall.mac
*			.include		fefunc.h
			.include		bg.h
			.include		const.h
*
FPACK		macro	callno
			.dc.w	callno
			.endm
*
__STOL		equ		$fe10
*
			.text
			.even
*
ent:
			lea.l	inisp(pc),07
			
			tst.b	(a2)+
			beq		usage
			
			movea.l	a2,a0
			FPACK	__STOL
			bcs		usage
			move.w	d0,d2				* d2.w = ス レツ ド ID
			
			FPACK	__STOL
			bcs		usage
			move.b	d0,d1				* d1.b = レ ペル
			subq.b	#2,d0
			bcc		do
			moveq.l	#2,d1
			
do:			lea.l 	thinfo(pc),a1		* 指定ID を持つ
			pea.l 	(a1)				* スレツドの管理情報を得る
			move.w 	d2,-(sp)			*
			DOS 	_GET_PR				*
			addq.l 	#6.sp				*
			tst.l 	d0					*
			bmi		nfound				*
			
			move.l	(a1),d3				* d3 = 次のスレツド管理情報
			
			move.l	d3,d0				* スレツド管理情報の
			moveq.l #thNMAX-1,d4		*  本体を 拐す
sealp:		movea.l d0,a1				*
			IOCS	_B_BPEEK			*
			cmp.l 	d3,d0				*
			dbeq	d4,sealp			*
			bne		nfound				*
			
										* al = スレツド管理情報の本体+4
			addq.l 	#thLeVEL-4,a1		* 実行優先レベルを苗き換える
			subq.b 	#1,d1				*
			IOSC	_B_BPOKE			*
			
			DOS		_EXIT
*
usage:		lea.l	usgmes(pc),a0
			bra		error
nfound		lea.l 	errmes(pc),a0
			*
error:		move.w	#STDERR,-(sp)
			pea.l 	(a0)
			DOS		_FPUTS
*			addq.l 	#6,sp

			move.w 	#1,-(sp)
			DOS		_EXIT2
usgmes:		.dc.b 	'機能： ス レリ ドの 実行 ほ 先 レベル'
			.dc.b 	'変実する',CB,LF
			.dc.b 	'使用ま： RENICE ス レツ ド ID (0-31)'
			.dc.b 	'レベル(2 - 255) ',CR,LF,0
			.dc.b   '脆のスレツドが見つかりませ ',CR,LF,0
*
			.bss
			.even
*
thinfo:		.ds.b  	SIZEofTHREADINFO
*
			.stack
			.even
*
inisp:

			.end	ent
			
────────────────────────────────────────────────────────────────────────────────

リスト 1 は Human68k の ワーク を 書き換えて し まう という 点で 悪い プ ログ ラム だが， 書き換える 位 置 を 算出す る 手順 は 正当 といえる も の だ。 
基本 線で は 公開 されて いる 情報 しか 使って おらず， Hunian68 k 内部の ワーク を 絶対 アドレス で 参照 している わけ ではない。 入に よって は， どうせ 悪さ をす るなら Human68k の ワーク を 舰 いて ス レツ ド 情報の ァ ド レス を 得て し ま えば よ いと 考える か も しれない 力 5 , ほかに 手が あるなら 少々 ま どろつ こしくても そっちを 使う のが 僕の 美意識 だ 6) 。




で， リスト 1 では get_pr で 指定 ID のスレ ッ ド情報の コピー を 得たら， その 先頭に ある "つぎの ス レツ ド 情報 を 指す ポインタ" をた どって， コピーと 同じものが Human68k 内部の ど こ にある か を 探して い る。
ス レツ ド 情報 は Human68k 内部で も get— pr の 返 す 形式 （リ スト 2 ： 11〜33 行） のま ま 保持され ており， ま た， 最後の ス レツ ド 情報 と 先頭の ス レツ ド 情報が 輪に なって いる" ので， この 方法 はう まく 働く。 
ス レツ ド ID 0 のス レツ ド 情報 を 得て， 必要な 回数 だ け ポインタ をた どる 方法 も ある 力、 その 場合， 引数 で 指定され たス レツ ド ID が 有効 かど うか をべ つに 調べなければ ならない。 
リ ス ト 1 では 指定の ス レツ HD が 有効 か ど う か は get_pr を 呼び出 したと き に わかる。



------   スレッドの 状態と スレッド 間 通信    ----------

スレッドに はァク ティ ブ 状態 と ス リ 一プ 状態が あ る。 
字面から 読み取れ ると 思う が， ふつうに 動いて いる 状態 を アクティブ， 一時的に 停止して 侍 機して いる 状態 を スリープと 表現す る。 
スリープ 状態の ス レ ッ ドには 実行権が 回って こない。

ノ 《ッ ク グラウン ド タスク はかなら ずし も ひっきり なしに 走って いな くても よ い 場合が 多い。 
た と えば， 時計 プログラムの 場合， 基本的に は 1 秒に 1 回 画面 を 書き換えれ ばよ いわけ だ。 
このように， 1 回 まと まった 処理 をしたら しばらく する こ とがない と き， バックグラウンド タスク は自 発 的 に一 定期 間 ス リ 一 プ して CPU 時間の 浪費 を 防ぐ の が 礼儀 とされる"。

ス リ 一プす る に は DOS コール sleep_pr を 使う。 ス リ 一 プ する 時間 は 引数で lms 単位で 指定で きる。 
特に 0 を 指定 し た 場合 は 無限 と 解釈 さ れ， 外部 か らス レツ ド間 通信に よ り 起こされ るまで スリ 一プし 続ける。 
ま た， open_pr で 生成され た 直後の スレ ッ ド は無条 件に スリープ 状態になる。 
このと きの 待ち時間 は open_pr の 最後の （最初に スタックに 積む） 引数で 指定 する。







自分 以外の ス レツ ドをス リーブさせる 方法 は 2 通 り ある。 
ひとつ は， スレッド 間 通信で スリープ する よう 要求す る 方法 だ。 
この場合， 通信 を 受け取った ス レツ ドが 自発的に ス リ 一プ する こ と になる ので， その プロ グラ ムがス リ ープ 要求 コマ ン ドをサ ポー ト していなければ 意味がない 9 >。 
強制的に スリ 一プさ せる に は， DOS コール suspend_pr を 使 う。 (10
suspend pr はス レツ ド間 通信 を 使わずに， 強制的に 指定 ス レツ ド を スリ一 プ 状態 にす る 山 。 
suspend_pr で 止 め ら れ た ス レツ ド は， やはり ス レツ ド 間 通信で 起 こされ る まで ス リーブし 続ける。

た び た び 登場 した スレ ッ ド 間 通信 は DOS コール send_pr を 使って 行 う 。 
send_pr では 任意の ス レツ ド に対して， 16 ビットの コマンドと， もし 必要なら 不定 長の 付随 データ を 送る ことができる。 
送り先 ス レッド は スリープ 状態で あっても よい。 
通信 を 送ら れ たスレ ッ ド は 自 動的 にァク ティ ブ 状態 になる。 
こ のとき， 受 け 手 側で は sleep_pr か らの 戻り 値に よ り ， 通信に よって 起こされた のか， 待ち時間が 過ぎた の か を 区別で きる。 
なお， すでに 通信が 入って いる 状 態で スリープ しょ う と しても sleep_pr から はすぐ に 戻り， スリープで きないよう になって いる。




通信 内容 は各ス レ ッ ドご と に 用意され た 通信 バッファに 3? き 込まれる。 
通信 バッファ は リス 卜 2 でい う と 42〜49 行の よ うな 構造 をして いる。 
通信 を 受け 取る ために は， 事前に データ 格納 領域の 先頭 ァ ド レ ス とその 大きさ を 設定し， また, 送り 乎の スレッド ID 格納 フ ィ一 ルドに一 1 を 入れて おく 必要が あ る 。 
スリープ しない プロ グラ ム の 場合 は. こ の ID 格納 フィールドが一 1 か ど う かで 通信が あつたか ど う 力' を 判断する。 
ここで， 通信が 入る と データ 領域 先頭 ァ ドレス 以外の フィ ール ドは 上書き される ことにな るので， 再び 通信 を 受けつ ける ようにす るに は， Mi 信の Jlit 瑰が 済み 次第， バッファ を リセット しないと ならない こ とに 注意し よ う。 
コマンド コー ド は 基本的 に は «• アプリケーションが 独自に 意味 を 与えて 使用す る こ とがで き る。 
ただ し ， FFxxh のコ マンド コード は システム によって 予約され てお り， と 〈に そ の 一部 に は リスト 2 の 57 ~60 行の よ う な 意味が 定義され ている。 


リス 卜 2 BG.H
────────────────────────────────────────────────────────────────────────────────────────────────────
*		パッヲグラウンドプロセス用定数11111; .~定終

thMAX			equ		32		* 椛大スレー，ド
*
thUSER			equ		$0000	* ユーザ一 モー ト' で 走る
thSUPER			equ		$2000	* スーパー パイ ザ モー 卜' で 走る

*
*	 ス レツ ド 画 蹄
*
				.offset 0
*
thNEXT:			.ds.l 	1		* つきの スレヅ 卜'
thWAITFLAG:		.ds.b 	1		* ス リーフ 中 かどう 力め フラグ
								* 00h ... 起きて いる
								* FEh ... 強制 スリーブ 中
								* FFh ... スリープ' 中
thCOUNT:		.ds.b 	1		* 実行 ほ: お 位 づけ 用 カウンタ
thLEVEL: 		.ds.b 	1		* 芙 m« 先 レベル- 
thDOSCOMMAND:	.ds.b 	1		* 実 H 中た つた DOS コール 番号
thPSP:			.ds.l 	1		* psp
thUSP:			.ds.l 	1		* usp
thDREG:			.ds.l 	8		* d0 - d7
thAREG:			.ds.l 	7		* a0 - a6
thSR:			.ds.w	1		* sr
thPC:			.ds.l 	1		* pc
thSSP:			.ds.l 	1		* ssp
thINDOSF:		.ds.w 	1		* (DOS 	コール;? -ス ティング レベル)
thINDOSP:		.ds.w 	1		* (DOS コール！ iflS 屮の ssp)
thBUFF:			.ds.l	1		* スレ' ソ 卜 fHliifg' ('ソフ
thNAME:			.ds.b   16		* スレ' ソ 卜 
thWAITTIME:		.ds.l 	1		* スリーブ HflW]?S 
SIZEofTHREADINFO:
				.text
*
thNAMED			equ 	-1		* スレ' ソ 卜て m 定 する
thMYSELF		equ		-2		* r に' >r!j'

*
*	スレ' ド間通 ほバ" 'フ t
*
				.offset 0		* - 糊 ほハ
*
thCOMMDATALEN:	.ds.l	1		* 打'"ァ、ハ fト数
								* (通 I 躺はデ 一タバイ トぉ)
thCOMMDATA:		.ds.l	1		* デ一サ 嗣搠ゅも閗 ァ ドレス
thCOMMCOMMAND:	.ds.w 	1		* コ マンド
thCOMMID:		.ds.w	1		* ---
SIZEofCOMMBUFF:
				.text
thEMPTY			equ 	-1 		* ス レツ ド間通 ほ ハリファに データ か' ない

*
*		スレヅ ド 間通ほコマソド
*
thKILL			equ 	$fff9	* 破€要求
thWAKEUP		equ		$fffb	* ァゥ ティブに する
thSLEEP			equ		$fffc	* スリーブ 要: R
thISBUSY		equ		$ffff	* ス レツ卜閱通ほ 可 微> どう 力 か

*
*		-----
*
thCONFLICT		equ		-27		* 同名の ス レツ トが fHJ する
thBUSY			equ		-28		* ス レツ i-'ftfbsm^^ けつ けら; f ぬい
thNOMORE		equ		-29		* これ w 上ス レ ソ ト' を a« できな

────────────────────────────────────────────────────────────────────────────────────────────────────

破棄 要求 (FFF9 h) と ス リ ープ 要求 （FFFCh) について はすで に 触れた。 
FFFBh は 特別な コ マン ド であ り ， 通信 先の スレッド を アクティブに する だけで， ス レツ ド 間 通信 バ ッファ は 変化 さ せない （ = 实 際に は 通信 し ない）。 
これ は， スレッド 間 通信の 処现 途中で suspend_pr で 止め ら れた ス レツ ド を 起こす とき に， 通信 バッ ファ 内容 を 変えて し ま わないた めの 仕様 だろ う通信 可能 か ど う かの 検査 コマ ン ド (FFFFh) は と にかく 通信して みて， 受け付けられた かど う 力' を 調 ベる コマ ン ドだ。 
送 り 先の 通信 バ ッファ に ま だ未処 理 のデ一 タ が あ る と send_pr はェ ラー コード 一28 を 返す ので， 通信 可能 かど うかがわ かる。 
ただ， この コマンド を 実際に 使う こ と は あま りないだろう。 
ァ ク ティブに する コマ ン ド FFFBh 同様の 特別扱い に は な つて おら ず 実際に コ マン ドが送 られる ため， 続けて べつの コ マン ドを 送る に は 送り先が 検^ コ マン ドを 処现 して ス レツ ド間 通信 バ ッファ を リセットす るの を 侍たなければ な ら ない。 

これな ら 最 初から 送 り たい コマ ン ドを 直接 送って， エラーの 有無 を 調べ た ほ う が 利口 だ。

ス レツ ド問 通信の 利用 例 として， リスト 3 に 任意 のス レツ ドを 破棄す る プログラム を 示す。 
単に 破棄 要求 コマ ン ドを 送って いる だけな ので， send_pr の 使用例 として の 意味 しかない が， 29 行の コマンド コー ド を 変 え れ ば， ス リ 一 プ 要求 を 送る プログラム， ァ ク ティ ブに する プロ グラ ム にもす ぐ 化け る 。 
ま た， ス レツ ド問 通信 力' ら は 離れ る が, 27—33 行 を,

move . w d0, ― (sp)

DOS .SUSPEND

addq.l #2,sp 

に すれば， 強制 ス リ ープ させる プログラムに も なる。 ひと とおり 用 意 なして おけば， 何 かの 役に は 立つ だろラ。

ただ， リスト 3 に は 手抜き 力； 'いっぱい ある。 

リス 卜 3 KILL.S
────────────────────────────────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────────────────────────────────


第 1 に， 本来 send_pr では 引数で 送 り 主の ス レ ッ ド ID を 指定して I'J 分の 身分 を 明らかにする こ と になって い る の だが に'， リスト 3 では ほ 分が メイン スレッドで ある こと を 仮定して （その 仮定 は 通常 成り立つ が)， 自分の スレッド ID を 取得す るの を 怠って いる。 
第 2 に， 相手が 通信 を 受け取つ たか ど う か を 確認 し て いない。 笫3 に， 相手が ちゃんと 自己 破棄した かど うか も 確認して いない。 
第 4 に， そもそも 破棄 要求 は あ まりう かつに 送って よい もので はない。 
プロ グ ラムに よって は， 破棄に 先立って べつの プログラム (通常， その プログラムの 非 常駐 部） が ある 程度の あ と 始末 をす る こと を 前提に している 場合が ある。 
い ちおう， TIMER. X と PRINT. X では 問題ない よ う た' が, ほかの プロ グラ ム では 誤 f 力作す る こと も あるだろ。


------    バックグラウンド 処理 プログラム   ----------

そろ そ ろ 実際に バッ クグラ ゥ ン ド処理 を 行 う プロ グラムの 例 を 示す としょう。 
リス 卜 4 は 単独で ァセ ン ブル/リンクして 実行す ると 常駐し， ファンク ショ ンキ 一行の 左端に A〜Z の 文字 を 順に 表示し 続ける。 
/R オプション により ス レツ ド を 破棄 し て 常駐 解除 する。 
まったく 実用 性の ない プログラム では ある 力 5 , パッ ク グラウン ド 処理 プログラム と して はかな り 真 面目に 作って あるので， たぶん， このまま ス ケルト ン と して 利用で き ると 思う。

リス 卜 4 BGTEST.S
────────────────────────────────────────────────────────────────────────────────────────────────────
01:	*		/(ックグラウンドフロセスのテストアロゲラム

					.include			doscall.mac
					.include			iocscall.mac
					.include			bg.h
					.include			const.h
	*
					.offset 0							* 常耳t都ワーヴの摘造
	*
10:	combuf:			.ds.b 		SIZEofCOMMBUFF			* J!if君ハッファ
	a6sav:			.ds.l 		1						* a6待選用
	spsav:			.ds.l 		1						* sp待選用
	SIZEofWORK:
	*
					.text
					.even
	*
	*	---
	*
20:	keepst:
	bgent:			lea.l 		work(pc), a6			* 寧ワーヲアウセス用
					movem.l		a6/sp,a6sav(a6)			* 中断時に備えて
														* a6， spを待選

					pea.l		break(pc)				* ------
					move.w		#_CTRLVC,-(sp)			* 殺定
					DOS			_INTVCS					*
					move.w		#_ERRJVC,(sp)			*
					DOS			_INTVCS					*
30:					addq.l		#6,sp					*
					
	loop:			cmpi.w		#thEMPTY,combuf+thCOMMID(a6)
					beq			main					* -------
														* -------
													
					move.w		combuf+thCOMMCOMMAND(a6),d0
														* d0 = コマンド
					move.w		#thEMPTY,combuf+thCOMMID(a6)
														* iMfiiを許可する
40:
					cmpi.w		#thKILL,d0				* 破棄要求?
					bne 		nkill
					
					DOS			_KILL_PR,d0				* 自身を破棄する
					bra 		loop
					
	nkill:			cmpi.w 		@thSLEEP.d0				* スリーブ要求?
					bne 		main
					
50:					clr.l 		-(sp)					* 考永久スリープする
					DOS			_SLEEP_PR				*
					addq.lea	#4,sp					*
					bra			loop

	main:			moveq.l		#3,d1					* 額面I左下に
					moveq.l		#0,d2					* 'A' - 'Z'を
					moveq.l 	#31,d3					* mに表示する
					moveq.l 	#1-1，d4					*
					lea.l 		char(pc)，a1				*
60:					addq.b 		#1， (a1)				*
					cmpi.b 		#'Z'+1(a1)				*
					bcs			put						*
					move.d0		#'A',(a1)				*
	put:			IOCS		_B_PUTMES				*

	wait:			pea.l		100,w					* 0.1 ---
					DOS			_SLEEP_PR				* スリープする
					addq.l		#4,sp					*
					bra			loop
70:					
	char:			.dc.b 		'@',0

	*
	*	."断E勃品理
	*
	break:			movem.l		work+a6sav(pc),a6/sp	* レジスタをIlU帯する
					bra			loop

	*
80:	*	常駐部ワーク
	*
	work:			.dc.l 		0						* スhuvy.剛ー-一巳回Jt・1リノフア
					.dc.l		0						*
					.dc.w		0						*
					.dc.w 		thEMPTY					*
					.dc.b		SIZEofWORK-SIZEofCOMMBUFF
	*
	iniusp			equ 		*+1024					* ユーザースヲッウ末尾
	inissp			equ			iniusp+1024*6			* スーパーバイザスヲック来!草
90:	keeped			equ			inissp					* 寺常駐都末尾
	KEEPSIZ			equ			keeped-keepst			*常.t.部バイト数

	*************************************************************************
	*
	*		---
	*
	ent:
					lea.l 		inisp(pc),sp
					
100:				DOS			_VERNUM					* Human68k の
					cmpi.w 		#0200,d0				* パージョンを隠T
					bcs			vererr					*
	*				cmpi.w		#$0232,d0				*
	*				bcc			vererr					*

					tst.b		(a2)+					*号l数がなければ
					beq			keep					* 常駐処理へ
	skippsp:		move.b		(a2)+,d0				*
					beq			keep					*
110:				cmpi.b		#SPACE,d0				*
					beq			skipsp					*
					cmpi.b		#TAB,d0					*
					beq			skipsp					*
					
					cmpi.b		#'-',d0					* シ ヨ ン の 植 ノオ
					beq			chkopt					*
					cmpi.b		#'/',d0					*
					bne			usage					*
														*
120:chkopt:			moveq.l 	#$20,d0					*
					or.b 		(a2)+,d0				*
					cmpi.b 		#'r',d0					* r オ吋 ノ シ ヨ 、?
					bne			usage

	*
	*		常駐解除処理
	*
	remove:			lea.l		myname(pc), a0			* 	----
					lea.l		thinfo+thNAME(pc),a1	*  ----
130:cpylp:			move.b		(a0)+,(a1)+				*
					bne			cpylp					*
														*
					pea.l		thinfo(pc)				*
					move.w		#thNamed,-(sp)			*
					DOS			_GET_PR					*
	*				addq.l		#6,sp					*
					tst.l		d0						*
					bmi			rmerr1					* なかった
					move.w		d0,d1					* d1 = スレ1ノドID
140:				
					pea.l		thinfo(pc)				* 自分のスレッドIDを得る
					move.w		#thMYSELF, -(sp)		*
					DOS			_GET_PR					*
					addq.l		#6,sp					* d0 = 自分のスレッドID
					
					clr.l		-(sp)					* とりあえず起こす
					clr.l		-(sp)					*
					move.w		#thWAKEUP,-(sp)			*
					move.w		d1,-(sp)				*
150:				move.w		d0,-(sp)				*
					DOS			_SEND_PR				*
					
					move.w		#thKILL,4(sp)			* -------
					moveq.l		#thBUSY,d2				* ------
					bra			send					*
														*
	sendlp:			DOS			_CHANGE_PR				*
														*
	send:			DOS			_SEND_PR				*
160:				cmp.l		d2,d0					*
					beq			sendlp					*
	*				lea.l		14(sp),sp				*

					tst.l		d0						* 異常発生
					bmi			rmerr2					*
					
					pea.l		thinfo(pc)				*京事Eんだの服認する
					move.w		d1,-(sp)				*
	waitlp:			DOS			_CHANGE_PR				*
170:													*
					DOS			_GET_PR					*
					tst.l		d0						*
					bpl			waitlp					*
					addq.l		#6,sp					*

					pea.l		remmes(pc)				* --------
					DOS			_PRINT					*
					addq.l		#4,sp					*
					
180:				DOS			_EXIT

	*
	*			常駐処理
	*
	keep:										*¥ッヲゲラウンドヲスクを貨録する
					pea.l		1.w						* 事スリー;:1Jr，i問 1ms
					pea.l		work+combuf(pc)			* スレ、ノド側通信パ‘ノプァ
					pea.l		bgent(pc)				* 初期pc (実行開始アドレス)
					move.w		#thUSER,-(sp)			* 初期sr (ユーザーモード)
190:				pea.l		inissp(pc)				* 初期ssp
					pea.l		iniusp(pc)				* 初期usp
					move.w		#2,-(sp)				* 実行優先レベル最高
					pea.l		myname(pc)				* スレヴド名
					DOS			_OPEN_PR				*
	*				lea.l		28(sp),sp				*
					tst.l		d0						*
					bmi			kperr					* 蛍続失敗
					
					pea.l		keepms(pc)				* 常耳Eメ‘ノセージを出力
200:				DOS			_PRINT					*
	*				addq.l		#4,sp					*
	
					clr.w		-(sp)					* 常駐終了
					move.l		#KEEPSIZ,-(sp)			*
					DOS			_KEEPPR					*

	*
	*			エラー終了
	*
210:kperr:			lea.l		errms1(pc),a0			* 車喝、甫軍司E1νようレ'』'υえ
					moveq.l		#thCONFLICT,d1			*
					cmp.l		d1, d0					*
				beq			error
					*
					lea.l		errms2(pc),a0			* スレッド数の限界
					moveq.l		#thNOMORE,d1			*
					cpm.l		d1,d0					*
					beq			error					*
					*
220:				lea.l		errms0(pc),a0			* processカ号量定されていない
					bra			error					*
	*
	rmerr1:			lea.l		errms3(pc),a0			* 常uしていないのに
					bra			error					* 常駐解除しようとした
	*
	rmerr2:			lea.l		errms4(pc),a0			* 帯男tIi孫釦=失敗した
					bra			error					*
	*
	vererr:			lea.l		verrms(pc),a0			* Human68k の
230:				bra			error					* パージョンが途う
	*
	usage:			lea.l		usgmes(pc),a0			* 使用法の表示
					*
	error:			move.w		#STDERR,-(sp)			* メッセージを
					pea.l		(a0)					* 標i韓エラー出力へ出力
					DOS			_FPUTS					*
	*				addq.l		#6.sp					*

					move.w		#1,-(sp)				* エラー終了
240:				DOS			_EXIT2					*
	*
	myname:			.dc.b		'BGTEST',0				* 自分のスレッド名
	*
	keepms			.dc.b		'BGTESTが割tしました'，CR，LF，0
	remmes: 		.dc.b		'BGTESTを切り離しました'，CR，LF，0
	*
	errms0: 		.dc.b		'CONFIG.SYSのPROCESSが'
					.dc.b		'!1定されていないようです' CR， LF， 0
	errmsl: 		.dc.b		'BGTESnますてに常駐しています t', CR, LF， 0
250:errms2: 		.dc.b		'これ以上パ， 7グラウンドプロセスを 組動できませんI', CR, LF, 0
					.dc.b		'組動できません', CR, LF, 0
	errms3: 		.dc.b		'BGTESTはまだ組み込まれていません'，CR，LF，0
	errms4: 		.dc.b		'BGTESTが制1ft併できません'，CR， LF ，0
	verrms:			.dc.b		'Human68kのパージョンが違います'，CR， LF， 0
	*
	usages:			.dc.b		'機能 パッヲグラウンドプロセスのテス ト'，CR， LF
					.dc.b		'使用法 BGTEST I/RJ'，CR，LF
					.dc.b		TAB，'./R' ，TAB， '常駐解除する'， CR，LF, 0
	*
260:				.bss
					.even
	*
	thinfo:			.ds.b		SIZEofTHREADINFO		* スレッド情報絡納領域
	*
					.stack
					.even
	*
					.ds.l		2048
	inisp:
270:
					.end		ent
				
────────────────────────────────────────────────────────────────────────────────────────────────────


非 常駐 部から みてい こ う。 
常駐 プログラムの 鉄則 どおり， 非 常駐 部 は 常駐 部のう しろ， 97 行から 始ま る。 
100〜102行では1^01311681<のバージョンを確認 している。 先月 触れ そこねた の だ 力 s ， Human68k ver 2.0 の 機能 を 利 ffl する 場合 はパ一 ジョン 番号が 2. 00 以降で あ る こと を 確認 し な ければ な ら ない。 
な お， 『プログラマー ズ マニュアル』 の サンプル プロ グラムで はこれ に加えて バージョン 2. 50 未満で ある こ と を 確認して いる 力 s ， 理由が 示されて いないし， TIMER. X は そ う なって いないよ う なので こ こで はコメ ン 卜で 殺して ある。 
好みに 応じて 復活 させても らい たい。

106~123 行で/ R ォプシ ョ ンの 指定の 有無 を 確認 し， 指定がなければ 185 行の 常駐 処理に 飛ぶ。 
通常 の 常駐 プ ログ ラムよりも 常駐す る た めの 処理が 簡単 になって いる こと に 注目 して ほしい。 
常駐 プロ グラ ム では 多重 常駐 を 防ぐ ために， すでに 自分と 同じ プ 口 グ ラ ム が 常駐 している かどう か 調べ る 必要が あ る わ けだが， ノ 《 ッ クグラ ゥ ン ド処理 プロ グラ ムの 場合， open_pr です でに 存在す る スレッドと 同名の ス レツ ド 名で タ スクを 登録しょう とすると ェ ラーが 返 る ので， 特に 気 を 払わな く て も 多重 常駐が 防げる 131 。 




あ と は 常駐 メ ッ セージ を 出して， 常駐 終了す る だけ だ。 
た だ， リスト 4 では ここ で 一瞬 危険 区域 を 通過す る。 
もし， open_pr から 戻って 常駐 終了す るまでの あい だに 何ら かの 理由で 実行が 中断され る と， スレッド が 生成され たのに 常駐し ないで 終了す る こ と になり， 間違いな く 暴走す るだろう。 
以前， 常駐 プログラム を 作つ たと きに， そのような こと がない よ う 中断 時 の 戻り アドレス を 設定し て 再 試行す る 方法 を 示し た が, こ の プロ グラ ム では どうやっても 危険 区域が 残つ てし まうよう なので， 開き直って 無視して いる。 
あ と は タイ ミン グ 悪く キーボードの 上に 何 かが 降って きて BREAK キー や COPY キーな ど を 押して しまわ ない こ と を 祈ろう。

危険 区域 といえば， リスト 4 では 常駐 部の ス タ ッ ク を 非 常駐 部 と 重ねて 確保 している （88〜89 行） ため， ス レツ ドを 生成して から 常駐 終了す る までの あいだ は 常駐 部の スタックの 中 を 走る 格好に なる。 
いちお う 注意して 作って あるので 問題 は 起きない 力 f , リ ス ト 4 を 流用す る 場合 は スタック と 常駐 部の 大きさ や 位置 関係に は 気をつけても らいたい。

もう ひとつ， ス タツ クで 思い出し た。 バック グラ ゥ ン ド処理 プロ グラ ム では 少な く と も スーパー バイ ザ スタック として 6 K バイ ト を 確保す る ことにな つ ている。 
実際に はこれ に ユーザー スタ ックが 加わる。 
リスト 4 のように 常駐 部の ス タツ クを非 常駐 部 と 重 ねて 確保す る 場合， 6 K バイ ト も あれば 非 常駐 部 は スタックに 使う 分 を 含めて 十分 収まる。 
し 力' し， 収 めて しまって はならない。 
収まって しま う 場合 は， 非 常駐 部 用の スタック を 大きめ にと り （リスト 4 も そうな つてい る）， 故意に 常駐 サイズよりも 広い メ モ リ を 確保 してお く。 
プログラム が 起動時に 与え ら れ るの は スタック セクションの 末尾までで， そのう しろに メモリが まだ ある という 保証 はない" に それ 以上の 大きさの メモリ を 確保す る 形で 常駐で きる か ど う か はわから ない の だ。 
リスト 4 のよう に equ で 常駐 部の 末尾 ァ ドレス を 表す 場合 は 気がつかない う ちに はみ出して しまって いる ことがあ るので， 十分 気をつけ るよ う にしたい。

128 行 以下の 常駐 解除 処 理 では， 常駐 部に 破棄 要 求 を 送り， 常駐 部が 自殺す るの を 侍つ， という 処理 をして いる。 
一般の 常駐 プログラム のように 常駐 部 力 f どこに あるの か 探してから メモリ を 解放す る といつ た 手順 を 踏む 必要 はない。 
まず， 128~139 行で 破棄 要求の 送り先 スレッドの スレッド ID を 得る。 
通常， get_pr は ス レツ ド ID で 指定 した スレ ッ ドの 管理 情 報 を 返す わけ だが， 管理情報 を 受け取る メ モ リ 領域 のス レツ ド 名が 格納され る 部分に ス レツ ド名を 書き 込んで おいて か らス レツ ド ID に一 2 を 指定す る と，get_pr がス レッド 名 に 対応す る スレッド を 探して く れ るよう になって いる。 
ここで エラ 一が 返 るよう な ら， まだ 常駐して いなかった ことになる。 続いて， 141 ~ 144 行で 自分の スレ ッ ド ID を 得 る。 
ス レツ ド ID に一 1 を 指定す ると 自分の ス レツ ド 管理情報 とス レツ ド ID 力 5 ; II る 。

146 行 以降 は， 先 ほ ど 手を抜いた ス レツ ド間 通信 のよ り 正しい 姿 を 示して いる。 146~ ほ 1 行で はと り あえず アクティブに する コマンド を 送って， 指定の スレッド を 起こす。 
これ は， リスト 3 を 改造した プ ログ ラム な ど を 使って， 通信 途中 に suspend_pr に よ り 強制 ス リ ープ 状態に さ れ てい る 可能性 を 考慮 し た も の だ。 
そ れか ら ， 159 行で 実際に 破棄 要求 を 送 る。 
このと き， 通信 ノ む ノファ に ま だ 未 処理の 通信 デー タ が 残つ ている こと を 表す ェ ラー コー ドが 返つ て き た. ら， 受けつ けられる まで 要求 を 送り 続ける。 
ここ で， 単 I ： send— pr を ル 一 プで括 つ た だ けで は あま り 意味がない こ と に 注意 して ほしい。 
1 回送 信す る た びに， いったん change_pr で 実行権 を 放棄して， 常 駐部 にス レツ ド 間 通信 パ ッファ を リセ ッ 卜する 時 問 を 与えなければ ならない。 
単に ループし ていて も い つか はス レツ ドが 切り替わる 力 ?， change_pr を 使つ た ほ う が 少な く と も プロ グラ ムは わか り やすくなる。

う ま く 通信で き る 力'， ある いは， send_pr が 予期 せぬ エラー コー ドを 返した 場合 は ループ を 抜けて 164 行に くる。 
エラ一 が 返った 場合 は あきらめて エラー 終了す る。 
すでに 送り先の スレッドが 存在す る こと は 確認して いる し， アクティブに も して あるから， 変な エラ一 コードが 返って きたら， それ はかな りの異常 事態 だ。 
ただ， 稀な ケースながら， 151 行で ァ ク ティ ブに した あとに その ス レツ ドが 破棄され て し まった， という 'び 能 性 も ゼロで はない。 
たとえば， すでに 破棄 要求が 送られて いて， それ を 処理す る 前 に suspend —pr で 止 め ら れ ていたの であ れば， 151 行 でァク ティ ブに した こと で 動き 出 してす ぐ 自殺す る。 
重箱の 隅 をつつ く よ う な 話 だが， 複数 プロ グラ ムが 並行 動作す る 環境で は， ほんの 少 し 前に 得た 情報が いつまでも 正しい と はか ぎらない という こ と は 頭に 入れて おいた ほうがよ いだろう。

無事， 通信が 送れたら， 今度 は それ を 常駐 部が 受 け 取つ て， 要求 ど おりに 自 己 破棄 を 行 うこと を 確認 す る 。 
get_pr で ス レツ ド 情報 を 取得 して， うまく 取 得で き る あいだ は その スレ ッ ドが まだ 生きて いる。 逆に get —pr がェ ラ 一を 返したら その ス レツ ドが 死ん だと 判断で きる。 
ここで も， 自殺す る 時間 を 与える ために 合間に change_pr を 呼び出 して 突 行 権 を 回 し て やる の を 忘れない。 
なお， 『プログラマ一 ズ マニュ アル』 に は change_pr と get_pr 1 回ず つ 呼び出せ ば， 破棄が うまくで き た かで きな かつ た を 判断で きるよう な 記述が あ る が， change_pr を 呼び出して か ら つぎに 実行権 力 ? 返って く る までの あいだに すべて の スレッドに 1 回ず つ 実行権が 渡 ると いう 保証 はな いのて"， リスト 4 のよう に change_pr と get_pr を ルー プで くくる のが 正しい と 思う。 
この場合， もし 破棄 要求が 無視され たら 無限ループに 陥る 力 s , 自分の 常 駐 部が 相手な の だから リ ス 卜 4 では その 心配 はない。 
自分の 常駐 部が と き に 破棄 要求 を 船 見す るよう になつ ている ので あれば， 繰り返し 回数 を 設定す るな り， 事前に 通信 を 交わして 破棄で き る 体勢 かどう か を 確 認 するな りする こ と に な る だろ う 。

非 常駐 部で は エラ一 処理 ルーチン （210~240 行）， と く に 常駐 時に open_pr が エラ一 を 返した と きの 処 理 にも 目 を 向けて ほしい。 
open_pr が 失敗す る 可能 性 として は，

1) CONFIG.SYS の PROCESS を 設定して いない

2) スレッド 数が すでに 限界に 達して いる

3) 同名の スレッドが 存在す る

力 5 ' 考えられ るので， エラ一 コー ドに 応じた エラー メ ッ セージ を 出す ようにして ある。 
手を抜いて，CONFIG.SYS の PROCESS が 設定 されて いな いか， スレッド 数が 限界に 達して いる 力'， 同名 のス レツ ドが 存在し ます など という エラ一 メ ッ セージ を 出した ので は COMMAND.X と 同 レベル 极 いされ て しまう。

20 行か ら の 常駐 部 をみ て もらおう。 
21 — 30 行が 初 期 化 部分。 
まず， 21 行で は ワーク エリア をァ ド レ ス レジスタ 間接で アクセス でき るよう にす るた めに， ワークの 先頭 アドレス を a6 に 入れて いる。 この プ ログ ラムで は ワーク を ほとんど 使わない ので 素直に 絶対 ァ ド レスで 参照す るよう にしても よ かった の だ が, レジスタが 余って いるの をい いこと に， こうい う 形に してみ た。 
ワークの 構造 は 8~13 行で 定義し て あり， その実 体 は 82~86 行に ある。

1 行 飛ば し て 25〜30 行で は CTRL+ C や ハー ド ゥ ェ ァ エラ 一によ る 中断 時の 処理 ァ ドレス を 設定して い る。 
この 設定 を しないと 中断 時の 処理 アドレス は 常 駐 処理 時の ままと なり， フォアグラウンド タスク を 止めよう と して CTRL+ C を 押 したと き に た ま た ま 制御が ノ ぐ ック グラウンド タスク 側 にあったり すると， ど こ か 変な と ころに 飛んで いって しまう 危険が ある。 
それ を 避ける ために， バック グラウン ド タスク はか な ら ず 中断 時の 処理 ァ ドレス を 設定し な ければ な ら ない 15 )。 
で, 飛ばした 22 行で は， 中断 時 処理から メ ィ ン処理 へ 回復す る と きに 備えて スタ ッ クポィ ンタ と ワーク アクセス 用の レジスタ を 待避して いる。 
中 断 時 処理 ルーチン に 制御が 移つ た ときには レジスタ 内容が 保証され ない ので， 再 設定す る （76 行） 必要が あるの だ。








32~69 行が メ ィ ン ループ だ。 
ス レツ ト" 間 通信 を処 理 し (32~53 行) , 1 文字 表示 し て (55—64 行) か ら 100 ms ほ ど ス リ ープす る （66~68t7—) という 処理の 繰 り 返しに なって いる。 通信が あつたか ど う かの 判定に は， sleep— pr の 戻 り 値 は 使わずに ス レツ ド問 通信 バッ ファを 直に 調べる 方法 を 採用して いる。

ス レツ ド間 通信の 処理 部 は， ス レツ ドの 破棄 要求 と ス リ ープ 要求 を サボ一 ト し た 標準 的な 作 り だ。 
32 〜33 行で 通信の 有無 を 確認し， 通信が 入って いた ら コマンド を 取り出し （36 行）， すかさず， バッファ を リセット して 通信 を 許可す る （38 行）。 
こ こで， 本来 は 通信の 処理が 完了して から バッファ をリ セットす る も の だが， こ の プロ ダラ ム では スレ ッ ド間 通信 パ' ッ ファの データ 領域の サイ ズを 最初から 0 にして ある ので コマ ン ド 以外の 付随 デ一 タ が 送 られる こと は な く， コマンド さえ 取り出して しまえば， 通信の 処理 屮 にべ つの 通信が 入つ て も 情報が 失わ れ る 危険 は な い。 
あと は， 破棄 要求が 送られて きたら kill_pr で 自殺 し （44 行）， ス リ ープ 要求が 送 ら れて き た ら sleep— pr で 永久 スリープに 入る （50~52 行）。 
戻って く る は ずの な い kil し pr の 直後の bra は緣起 も の だ。

1 文字 表示 部 はみ ての と お り で， そ れが 济ん だら 0.1 秒 ほど スリープして， ループす る。 
この ス リー プ する 部分 は， スリープ する 時間 を 変えたり， ス リー プす る ^ わ り に change_pr で 実行権 を 放棄 し た り ， あ る いは， sleep— pr も change 一 pr も I 乎ば' ずに ノ レープ 先頭に 飛んだり， といろ いろ 変えて みると， パック グラウン ド 処理に 対する 理解が 深ま るか も しれない。




------    さまざまな DOS コール    ------ 


最後に パッ ク グラウン ド処理 機能 関連の そのほかの DOS コール を 紹介して 終わろう。

time_pr は タイマ 割り込みの In ト数を カウン ト して いる 32 ビッ 卜の 値 を 返す。 間隔 を 空けて 呼び出せば， そ の 戻 り 値の 差 か ら , 1 ms 単位での 経過 時間が わ かる。 
複数の プログラムが 並行 動作して いると， 命 令の 実行時 間に 依存した 方法 11 "で 時間 を 扱う こ とが できな く な る ので， べつの 基準が 設け ら れた， と い う こ と だ。

s_malloc, s_free, s_process は， これ ま て ひと 続きの ものと しての み 扱われて いた メイ ン メモリ を， ス レツ ド ご と に 分割 し て 割 り 当てられる ようにす る も の だ。 
s_process でス レツ ドに衬 して この 割り 当 て を 行う と， 以後， その スレッドからの メモリ 確保 要求 は 割 り 当てられた メモリ の 範囲に 制限され る 1 "。 
こ の 機能 は， malloc で 必要に 応 じて メモリ を 確保 する バックグラウンド タスクに 対して， メモリ を予 約して おく 目的で 使う こ とになる だろう。 
フォア グラウ ン ドで走 る プログラム の 起動時に は 最大の メ モ リ ブロ ックカ ? 割 り 当て られ るので， いざ バック グラ ゥ ンドタ ス クが メモ リ を 確保 しょうと したと きに 使 える メモリがない こと も 考えられる。 
そこで， あらか じ め s_process でメ イン メモリ を 切り出して， そ のス レツ ド 専用 に 割 りつけ てお く というわけだ。 
で， s_malloc , s_free は 無条件に メイン スレッド にわ り あてられた メモリに 対して メモリ プロ ッ クの 確保 /解放 を 行う。

malloc2 は DOS コール malloc を メ モ リ 確保の 方法 が 指定で き るよう 改良した 上位 コール だ。 
malloc は メモリ の 確保 を 無条件に 若い ァ ドレス 側から 行つ たが, malloc2 では モード を 指定す る ことで， 逆に メ モ リ の 高位 側か ら 確保 し た り （モー ト" 2 ), あるい は， フリー メモリ 力 ； い く つかの ブロ ックに 分割され ている とき に 要求 サイ ズを 満たす 最小の プロ ック 力' ら メモリ を 割 り 当てた り （モー ド 1 ) といった こと 力 5 でき る。 
バック グラウン ド処理 と 直接の 関連 はない 力?， バッ チプ ログ ラ ム 中で プロ グラ ムを 常駐 させ る 際に メモリの 分 断 を 防ぐ 目的で 自身 を メモリの 最高 位に 移動 し た り する 場合に は 有効 だろ う 。

あ と は， exec がサ ポー トす るよう になった ォ一 パー レイ X フ アイ ルだ。 これ も パック グラウン ド 処 理 専用 という わ けで は な い 力、 常駐 部 と 非 常駐 部 を べつの X ファ ィ ルに して ある 場合な どに は それな りに 役に立つ。 
こ こで い う オーバーレイ X ファ ィ ルは 複数の X フ ァ ィ ルを BIND. X で ひ とまとめ にした もの を 指す。 
オーバーレイ X ファイル は， 単純に X ファイル を 連結し， 末尾に モジュール リスト を 付け 加えた 格好 をして いる。 
モジュール 一覧の 位置 は， 先頭 モジュールの X フ ァ ィ ル ヘッダに 格納され る。 参考までに X ファイルのへ ッ タ 1# 造 を 表 2 に 示して おく。 與 味の ある 人 は 適当に X ファイル を ダンプし て， 見比べて みると いいだろう。 ここで は， 03 II ノ ぐ ィ ト 目の ロード モー ド について だけ 触れて お く 。

比較的 最近 ま で 気づ かなかった の だが， この バイ 卜の 第 1 ビット を 立てて おくと， テキス トセ クシ ョ ン から スタック セクションまで がちよ う ど 収ま る だ けの メモリ ブロ ックが メモリの 高位 ァ ドレス 側から 確保 さ れ， プロ グラ ムは そこに ロードされ るよう に なる。 Human68k ver 2.0 での マイナーな 拡張 機能 だ。 
メモリの 高位に 常駐 部 を^く プログラム では 便利な 機能だろう。 なお， どうせ^れ オプションがある だろうと， いま LK.X で 試して みたら/ A ォプ シ ョ ンで 口一 ドモ一 ドの 設定が でき るよう だ。 
/A の 直後に は 立てたい ビッ ト 番号 を 指定す る。 0 から 7 ま でが 有効 だが， ^在^ 味が あ るの は 1 だけ だ。

ところで， 第 1 ビットと いうの がどう も 中途半端 だが， どうも 第 0 ビットに も 意味 を 待たせ， こ の ビ ッ ト が 1 だつ た ら malloc2 のモ一 ド 1 相当の 方法で メ モ リ を 割 り 当てる つも り だつ た らしい。 と ころ 力;'， Human68k の こ の 判定 部分が バグって 意味が な く なって しまったよう だ。

*   *    *

ノ 《ック グラウン ド処现 は 使いよ う によって は 便利 だし， 遊びが い も ある （こっちの ほう が 肝心 だな）。 複数 プ ログ ラムからの コンピュータ 資源の 共有に つ いて は少々 難があ り， ノ 《ッ ク グラウン ド タスク 力 ? 利 用で きる （しても よ い） 資源に 制約が ある 181 力 ? ， その 点に 目をつぶれば マル チタ スク つぼ さ も 味わえる。

それにしても， 前回， 今回と， 手元の 解析 メモ か ら 未 公開 情報 を 弓 I つ 張り出し てみ たわけ だが， 我 な がら， ずいぶん 無駄な こ と に 時間 を 使って いる もの だと 途中で 結構 情けな く なった。 
来年 はもつ と 有意 義に 時間 を 使いたい もの だ， と， 2 月 号で ある こと をす つかり 忘れて 実 時 tiU に 引き戻され そ う になる。

次回から は 文字列の 探索 をと り 上げる。 
たぶん， 来月 はふつ う の 文字列 探^で， 再来月 は そ の一 歩 先， へたす る ともう 1 回 費やして その また一 歩 先まで い く かも しれない。 来月に は 間に合わない た' ろう 力;'， クレーム をつ けるなら いまのう ちた〜。




