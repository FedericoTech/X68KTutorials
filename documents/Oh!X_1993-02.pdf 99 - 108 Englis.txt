
Oh!X_1993-02.pdf 99 - 108

Background SB Sato

Murata Toshiyuki, Satoshi Sunda

Continuing from last month, I will take up the extended functions of Human68k ver 2.0.
This time, I will explain the background processing function for executing several processes at the same time.
Using a program that uses this function as a concrete example, let's consider how to create it, how it resides, and how to execute it.

This time, we will create a program using the ground processing function that enables parallel execution of multiple programs.

We will look at the functions around the process/memory of Human68k ver 2.0, focusing on how to use it.
As usual, I won't go into much detail about how to invoke individual DOS calls, so please refer to the Programmer's Manual when appropriate.



------ Overview of background processing functions ----------

Needless to say, the power of multiple programs: even though they run in parallel, there is only one CPU

As mentioned above, only one program can be executed at a given moment. If you force it, run one program for a while, then run another program again, and so on, and switch control at sufficiently short intervals, it will be as if multiple programs are running in parallel. 
I can see it. This is the basis of so-called multitasking.
In general, task I' is switched by using a timer that periodically triggers task I'. Figure 1 shows the situation.
The horizontal axis is time and the vertical axis is the task being executed (conceptually the program counter).
If you look at it from the left, Program A is running first. A timer interrupt occurs here, and control passes to the interrupt routine. Task switching is performed by this timer interrupt routine.

Normally, an interrupt routine returns to the program that was being executed when the interrupt occurred after completing the necessary processing. ).
At this time, the position in program A to which it was originally supposed to return and the contents of the registers at the time the interrupt occurred are saved somewhere, and then execution of program A is resumed. • Go back to the original.
In this way, stealthily and indiscriminately changing the register contents in the interrupt routine = task switching.
Human68k's packed ground processing function basically executes multiple programs in parallel in this way.

Well, the word "task" has been used for the sake of convenience, but in Human68k's background processing function, "(thread)" is the management unit of parallel processing.
Thread means a series of things, and in this case, it refers to a sequence of program instructions that are processed sequentially or the flow of their processing.
ft Threads are identified by a number called a thread ID and a thread name2).
At startup, one main thread (thread ID is 0, thread name is "Human68k system") is prepared, and in the foreground 3')J program, that is, , COMMAND. X and each program that runs as a child process will run in this main thread".
When a task is registered by the DOS call open_pr from this state of only the main thread, a new thread is created and executed while sharing the CPU time with the main thread.
A packground task is always created as a resident program and always exits with the DOS call keeppr after open__pr.
At this time, if necessary, it is possible to place multiple tasks on the same memory block, register them individually with open_pr, and then collectively make them resident.
In that case, each task will share the environment as the same process.

To destroy a registered background task, use the DOS call kill_pr.
kill_pr destroy the thread to which the task that called it belongs, and also release the resident and occupied memory.
In the case of a multi-task background process, when one task commits suicide, all tasks that share the environment as the same process are brought along.
where kill_pr is just a ``suicide'' DOS call.
There is no direct way to destroy her threads other than your own.
In that case, he takes the method of sending a discard request through inter-thread communication to make it kill itself.
More on inter-thread communication later.



------ red switching actual ----------
The MFT timer D is used as the thread switching timer.
The IOCS call TIMERDST, which sets the timer D interrupt, is disabled when PROCESS is set and is no longer available to the user.
In addition, the timer D interrupt interval can be set finely, but even if it is set to the maximum, it is too short to be used as the thread switching interval. is fixed at 1 ms, and the interrupt routine counts the number of interrupts and switches threads at regular intervals.

Thread switching by interrupts is performed only in user mode. This is because system calls such as DOS calls and IOCS calls are not reentrant.
If thread switching is allowed even during system call processing, there is a possibility that the same system call will be issued from another thread before system call processing reaches the end. DOS and IOCS calls do not support such calls.
The timer interrupt routine checks to see if it was in supervisor mode before the interrupt by examining the sr pushed on the stack at the time of the interrupt, and if so, a system call (or other interrupt routine) and returns without switching threads. 
A side effect of this is that thread switching is stopped even during the execution of an application program running in supervisor mode.
Therefore, it is recommended that programs running in supervisor mode periodically call the DOS call change_pr, which voluntarily relinquishes execution and passes execution to another thread.

However, if the timer interrupt routine fails to switch threads, it sets an internal flag and returns. then it will switch threads (without interrupts).
Thus, even in a program running in supervisor mode, he will not completely stop thread switching if he issues DOS calls at appropriate intervals. Rather, it might be better to issue a dummy DOS call than change_pr if it's just a matter of not taking over the execution right.
Using change_pr also causes an unconditional thread switch even if there is still time left in the thread to be used, but any other DOS call will change the thread |!H Thread breaks only when cut.
As a DOS call to be used at this time, a harmless one that completes processing in a very short period of time, such as [curdrv], would be suitable.

In addition, thread switching is also performed when key input is interrupted during a DOS call.
The period in which the CPU is idle most is while waiting for the user's response, such as key input. Natural.
In the first place, the raison d'être of multitasking (in a single-user environment) is to make use of such wasted time.
Note that the IOCS call B_KEYINP is not tampered with in this way. Calling B_KEYINP when there is no key input ahead causes thread switching to stall until there is a key input.
To avoid this, B_KEYSNS must make sure there is data in the key buffer before calling B_KEYINP.

Now, thread switching is not simply done in order of thread ID.
& Threads are given an execution priority level, and Human68k considers this level when deciding which thread to pass execution rights to.
The execution priority level is represented by a value from 2 to 255, and the lower the value, the higher the level, meaning that more priority is given to CPU time.
As a rule of thumb, if the run level value is halved, the number of times execution rights are passed doubles.

By the way, Human68k implements thread switching with priority in the following way.
Instead, prepare a 1-byte counter for each thread and initialize it with the value of execution priority level -1.
When switching threads, look for the thread with the lowest counter value.
This search is performed in order of thread ID, starting with the thread next to the thread that has been executing so far.
If there is more than one thread with the lowest counter: Which one hits t?
Execution right is passed to the thread found in this way. At this time, the remainder of the thread's counter is subtracted from the other thread's counter, and at the same time, the counter of the thread to which execution right has been passed is set. reset.
Below is a repetition of this.
For reference, Table 1 shows the change in the counter when there are 3 threads with execution priority levels 3, 4, and 6 (in the table, the arrow indicates resetting his counter).


Thread A	│	Thread B	│	Thread C	│	Executed Two Reds
────────────┼───────────────┼───────────────┼─────────────────────
	2		│		3		│		5		│		initial state	
	0 → 2	│		1		│		3		│		Thread A
	1		│		0 → 3	│		2		│		Thread B
	0 → 2	│		2		│		1		│		Thread A
	1		│		1		│		0 → 5	│		Thread C
	0 → 2	│		0		│		4		│		Thread A
	2		│		0 → 3	│		4		│		Thread B
	0 → 2  	│		1		│		2		│		Thread A
	1		│		0 → 3	│		1		│		Thread B
	0		│		2		│		0 → 5	│		Thread C
	0 → 2	│		2		│		5		│		Thread A
	0		│		0 → 3	│		3		│		Thread B
	0 → 2	│		3		│		3		│		Thread A
	0 → 2	│		1		│		1		│		Thread A
	1		│		0 → 3	│		0		│		Thread B
	1		│		3		│		0 → 5	│		Thread C


By the way, the execution priority level can only be specified when registering a task with open_pr (on the PROCESS line of CONFIG.SYS in the case of the main thread), and there is a way to change it later. not So here's Listing 1.
Probably the only working program this month.
When a thread HD and an execution priority level are specified as arguments, the corresponding thread management information inside Human68k is directly rewritten to change the execution priority level. 
Place list 2 in the current directory when assembling.
List 2 is a background structure/constant definition file, which is commonly used in later programs.

Listing 1 RENICE.X
────────────────────────────────────────────────────────────────────────────────
01:	*			Change thread execution level
02
03				.include		doscall.mac
04				.include		ioscall.mac
05	*			.include		fefunc.h
06				.include		bg.h
07				.include		const.h
08	*
09	FPACK		macro	callno
10:				.dc.w	callno
11				.endm
12	*
13	__STOL		equ		$fe10
14	*
15				.text
16				.even
17	*
18	ent:
19				lea.l	inisp(pc),07
20:				
21				tst.b	(a2)+
22				beq		usage
23				
24				movea.l	a2,a0
25				FPACK	__STOL
26				bcs		usage
27				move.w	d0,d2				* d2.w = thread ID
28				
29				FPACK	__STOL
30:				bcs		usage
31				move.b	d0,d1				* d1.b = level
32				subq.b	#2,d0
33				bcc		do
34				moveq.l	#2,d1
35				
36	do:			lea.l 	thinfo(pc),a1		* have a specified ID
37				pea.l 	(a1)				* get thread management information
38				move.w 	d2,-(sp)			*
39				DOS 	_GET_PR				*
40:	*			addq.l 	#6.sp				*
41				tst.l 	d0					*
42				bmi		nfound				*
43				
44				move.l	(a1),d3				* d3 = Next Thread Management Information
45				
46				move.l	d3,d0				* Thread management information
47				moveq.l #thNMAX-1,d4		*  kidnap the main body
48	sealp:		movea.l d0,a1				*
49				IOCS	_B_BPEEK			*
50:				cmp.l 	d3,d0				*
51				dbeq	d4,sealp			*
52				bne		nfound				*
53				
54											* al = Body of thread management information +4
55				addq.l 	#thLeVEL-4,a1		* Change execution priority level
56				subq.b 	#1,d1				*
57				IOSC	_B_BPOKE			*
58				
59				DOS		_EXIT
60:	*
61	usage:		lea.l	usgmes(pc),a0
62				bra		error
63	nfound		lea.l 	errmes(pc),a0
64				*
65	error:		move.w	#STDERR,-(sp)
66				pea.l 	(a0)
67				DOS		_FPUTS
68	*			addq.l 	#6,sp
69
70:				move.w 	#1,-(sp)
71				DOS		_EXIT2
72	*
73	usgmes:		.dc.b 	'Feature: Thread execution top level'
74				.dc.b 	'change',CB,LF
75				.dc.b 	'use： RENICE Thread ID (0-31)'
76				.dc.b 	'level(2 - 255) ',CR,LF,0
77	errmes:		.dc.b   'fragile thread not found',CR,LF,0
78	*
79				.bss
80:				.even
81	*
82	thinfo:		.ds.b  	SIZEofTHREADINFO
83	*
84				.stack
85				.even
86	*
87				.ds.l	256
88	inisp:
89
90:				.end	ent
────────────────────────────────────────────────────────────────────────────────

List 1 is a bad program in that it rewrites the Human68k work, but the procedure for calculating the rewrite position is justified.
The basic line uses only publicly available information, and does not refer to the internal Hunian68 k work with absolute addresses. 
Depending on the input, you may think that if you're going to do bad things anyway, you should just ship Human68k's work and get the address of the thread information. 
It's my sense of beauty to use that even if it's tough6).

So, in List 1, if you get a copy of the thread information with the specified ID with get_pr, follow the "pointer pointing to the next thread information" at the top of it, and find the same thing as the copy anywhere in Human68k. I'm looking for something in
Thread information is retained inside Human68k as it is in the format returned by get_pr (List 2: lines 11-33). 
This method works well because the there is also a way to get the thread information for thread ID 0 and follow the pointer the required number of times. 
I have to. In Listing 1, you can tell if a given thread ID is valid when you call get_pr.



------ Thread State and Inter-Thread Communication ----------

A thread has an active state and a sleep state.
I think you can read it from the word, but he describes the state of normal movement as active, and the state of temporarily stopping and acting as a samurai machine as sleep.
The sleeping thread gets the right to execute and he doesn't come.

background tasks often don't require constant running.
For example, in the case of a clock program, basically the screen should be refreshed once a second.
Thus, when there is nothing to do for a while after doing a batch of work, it is customary for the background task to voluntarily sleep for a period of time to avoid wasting CPU time. ".

To sleep, use the DOS call sleep_pr. The sleep time can be specified in lms as an argument.
In particular, if 0 is specified, it will be interpreted as infinite, and will continue to slip until it is woken up by an external inter-thread communication.
In addition, the thread immediately after being created by open_pr is put to sleep state unconditionally.
The wait time at this time is specified by the last (first on her stack) argument of open_pr.

There are two ways to put threads other than your own to sleep.
One way is to request sleep in inter-thread communication.
In this case, the thread that received the communication will automatically go to sleep, so if the program does not support the sleep request command, it is meaningless9. >.
To force it to sleep, use the DOS call suspend_pr. (10
suspend_pr forcibly puts the specified thread into sleep state without using inter-thread communication.
A thread suspended with suspend_pr will continue to sleep until it is also awakened by inter-thread communication.

Inter-thread communication, which came up again and again, is done using the DOS call send_pr.
send_pr allows you to send a 16-bit command and, if necessary, an indeterminate length of accompanying data to any thread.
The destination thread may be asleep.
The thread to which the communication is sent automatically becomes active.
At this time, the receiving side can distinguish whether he was woken up by the communication or the waiting time has passed by the return value from sleep_pr.
Even if you try to go to sleep while communication is already in progress, it returns immediately from sleep_pr and cannot go to sleep.

The contents of communication are written into the communication buffer prepared for each thread.
The communication buffer has a structure like lines 42 to 49 in list 2.
In order to receive communication, it is necessary to set the top address of the data storage area and its size in advance, and to put 1 in the thread ID storage field of the message. .
In the case of a program that does not sleep, it is determined whether or not communication has occurred based on whether this ID storage field is 1 or not.
Here, when communication enters, fields other than the first address of the data area will be overwritten. Note that the buffer must be reset.
A command code can basically be used by an application giving it its own meaning.
However, the (FFxx h) command codes are reserved by the system, and some of them have defined meanings such as Listing 2, lines 57-60.

Listing 2 BG.H
────────────────────────────────────────────────────────────────────────────────────────────────────
01	*		constant / structure definitions for background process
02
03	thMAX			equ		32		* max threads	
04	*
05	thUSER			equ		$0000	* run in user mode
06	thSUPER			equ		$2000	* run in supervisor mode
07
08	*
09	*	 thread management information
10:	*
11					.offset 0
12	*
13	thNEXT:			.ds.l 	1		* next thread
14	thWAITFLAG:		.ds.b 	1		* flag whether in sleep or not
15								* 00h ... awake
16								* FEh ... during forced sleep
17								* FFh ... in sleep
18	thCOUNT:		.ds.b 	1		* counter of execution priority
19	thLEVEL: 		.ds.b 	1		* execution priority level -1
20:	thDOSCOMMAND:	.ds.b 	1		* DOS call number that was in progress
21	thPSP:			.ds.l 	1		* psp
22	thUSP:			.ds.l 	1		* usp
23	thDREG:			.ds.l 	8		* d0 - d7
24	thAREG:			.ds.l 	7		* a0 - a6
25	thSR:			.ds.w	1		* sr
26	thPC:			.ds.l 	1		* pc
27	thSSP:			.ds.l 	1		* ssp
28	thINDOSF:		.ds.w 	1		* (DOS call nesting level)
29	thINDOSP:		.ds.w 	1		* (ssp during DOS call processing)
30:	thBUFF:			.ds.l	1		* inner thread communication buffer
31	thNAME:			.ds.b   16		* thread name
32	thWAITTIME:		.ds.l 	1		* remaninning sleep time
33	SIZEofTHREADINFO:
34					.text
35	*
36	thNAMED			equ 	-1		* specify by thread name
37	thMYSELF		equ		-2		* myself
38	
39	*
40:	*	innter thread communication buffer
41	*
42					.offset 0		* inner thread communication buffer
43	*
44	thCOMMDATALEN:	.ds.l	1		* buffer bytes
45								* (number of data bytes during communication)
46	thCOMMDATA:		.ds.l	1		* data area start address
47	thCOMMCOMMAND:	.ds.w 	1		* command
48	thCOMMID:		.ds.w	1		* sender ID
49	SIZEofCOMMBUFF:
50:					.text
51	thEMPTY			equ 	-1 		* no data thread communication buffer
52
53	*
54	*		inner-thread communication commands
55	*
56	thKILL			equ 	$fff9	* discard request
57	thWAKEUP		equ		$fffb	* active
58	thSLEEP			equ		$fffc	* sleep request
59	thISBUSY		equ		$ffff	* check if inner-thread communication is possible.
60:	
61	*
62	*		-----
63	*
64	thCONFLICT		equ		-27		* there is a thread with the same name
65	thBUSY			equ		-28		* inner-thread communication not accepted
66	thNOMORE		equ		-29		* cannot register any more threads

────────────────────────────────────────────────────────────────────────────────────────────────────





Discard requests (FFF9 h) and sleep requests (FFFC h) have already been mentioned.
(FFFB h) is a special command that only activates the thread to communicate with, but does not change the inter-thread communication buffer (= does not actually communicate).
This is a specification to avoid changing the contents of the communication buffer when waking up a thread that has been suspended by suspend_pr in the middle of processing inter-thread communication. 
The check command (FFFF h) is a command to try to communicate and check whether it was accepted.
If there is still unprocessed data in the destination's communication buffer, send_pr will return error code -28, so you know if communication is possible.
However, you probably won't use this command very often.
The command to make it active (FFFB h) It is not treated as special as it is, and the command is actually sent. to reset the inter-thread communication buffer.

In this case, it would be smarter to directly send the command you want to send from the beginning and check for errors.

As an example of using inter-thread communication, List 3 shows a program that destroys an arbitrary thread.
Since it simply sends a discard request command, it only has meaning as an example of using send_pr. It can also be transformed into a program that makes it easy.
In addition, lines 27-33,

move . w d0, ― (sp)

DOS .SUSPEND

addq.l #2,sp 

It can also be a program that forces sleep. If you prepare everything, it will come in handy.

However, List 3 has the power to cut corners;

Listing 3 KILL.S
────────────────────────────────────────────────────────────────────────────────────────────────────

────────────────────────────────────────────────────────────────────────────────────────────────────

First, although send_pr is supposed to specify the thread ID of the sender as an argument to clarify the identity of I'J, List 3 is mostly Assuming it's the main thread (which is usually true) and neglecting to get its own thread id.
Second, you do not check to see if the other party received the communication. 笫3, the opponent has not confirmed whether he has properly destroyed himself.
Fourth, a discard request shouldn't be sent so carelessly in the first place.
Some programs assume that another program (usually a non-resident part of her program) will do some cleanup prior to destruction.
By the way, TIMER.X and PRINT.X seem to work fine, but other programs may make mistakes.


------ Background processing program ----------

I'll give you an example of a program that does some background work very soon.
When list 4 is assembled/linked and executed by itself, it becomes resident and continues to display the characters A to Z in sequence at the left end of the function key line.
The /R option destroys the thread and makes it unresident.
It's a completely useless program, but it's a pack ground processing program.

Listing 4 BGTEST.S
────────────────────────────────────────────────────────────────────────────────────────────────────
001:	*		background process test program
02:	
003:					.include			doscall.mac
004:					.include			iocscall.mac
005:					.include			bg.h
006:					.include			const.h
007:	*
008:					.offset 0							* resident work structure
009:	*
010:combuf:			.ds.b 		SIZEofCOMMBUFF			* communication buffer
011	a6sav:			.ds.l 		1						* for saving A6
012	spsav:			.ds.l 		1						* for saving SP
013	SIZEofWORK:
014	*
015					.text
016					.even
017	*
018	*	---
019	*
020:keepst:
021	bgent:			lea.l 		work(pc), a6			* for work process
022					movem.l		a6/sp,a6sav(a6)			* prepare interruptions
023														* save a6 and sp
024
025					pea.l		break(pc)				* set interrupt
026					move.w		#_CTRLVC,-(sp)			* processing address
027					DOS			_INTVCS					*
028					move.w		#_ERRJVC,(sp)			*
029					DOS			_INTVCS					*
030:				addq.l		#6,sp					*
031					
032	loop:			cmpi.w		#thEMPTY,combuf+thCOMMID(a6)
033					beq			main					* in inter-thread comunication
034														* do you have data?
035													
036					move.w		combuf+thCOMMCOMMAND(a6),d0
037														* d0 = command
038					move.w		#thEMPTY,combuf+thCOMMID(a6)
039														* allow communication
040:
041					cmpi.w		#thKILL,d0				* discard request?
042					bne 		nkill
043					
044					DOS			_KILL_PR,d0				* destroy itself
045					bra 		loop
046					
047	nkill:			cmpi.w 		@thSLEEP.d0				* sleep request?
048					bne 		main
049					
050:				clr.l 		-(sp)					* sleep
051					DOS			_SLEEP_PR				*
052					addq.lea	#4,sp					*
053					bra			loop
054
055	main:			moveq.l		#3,d1					* on the button left of the screen
056					moveq.l		#0,d2					* 'A' - 'Z'を
057					moveq.l 	#31,d3					* display in order
058					moveq.l 	#1-1，d4					*
059					lea.l 		char(pc)，a1				*
060:				addq.b 		#1， (a1)				*
061					cmpi.b 		#'Z'+1(a1)				*
062					bcs			put						*
063					move.d0		#'A',(a1)				*
064	put:			IOCS		_B_PUTMES				*
065
066	wait:			pea.l		100,w					* sleep for
067					DOS			_SLEEP_PR				* about 1 millisecond
068					addq.l		#4,sp					*
069					bra			loop
070:					
071	char:			.dc.b 		'@',0
072
073	*
074	*	suspend processing
075	*
076	break:			movem.l		work+a6sav(pc),a6/sp	* register
077					bra			loop
078
079	*
080:*	permanent block work
081	*
082	work:			.dc.l 		0						* inter-thread communication buffer
083					.dc.l		0						*
084					.dc.w		0						*
085					.dc.w 		thEMPTY					*
086					.dc.b		SIZEofWORK-SIZEofCOMMBUFF
087	*
088	iniusp			equ 		*+1024					* end of user stack
089	inissp			equ			iniusp+1024*6			* tail of supervisor stack
090:keeped			equ			inissp					* end of resident part
091	KEEPSIZ			equ			keeped-keepst			* number of bytes in resident part
092
093	*************************************************************************
094	*
095	*		part-time block
096	*
097	ent:
098					lea.l 		inisp(pc),sp
099					
100:				DOS			_VERNUM					* check Human68k
101					cmpi.w 		#0200,d0				* version
102					bcs			vererr					*
103	*				cmpi.w		#$0232,d0				*
104	*				bcc			vererr					*
105
106					tst.b		(a2)+					* if there is no argument
107					beq			keep					* to send to the resident process...
108	skippsp:		move.b		(a2)+,d0				*
109					beq			keep					*
110:				cmpi.b		#SPACE,d0				*
111					beq			skipsp					*
112					cmpi.b		#TAB,d0					*
113					beq			skipsp					*
114					
115					cmpi.b		#'-',d0					* check whether there is
116					beq			chkopt					* any param from command line
117					cmpi.b		#'/',d0					*
118					bne			usage					*
119														*
120:chkopt:			moveq.l 	#$20,d0					*
121					or.b 		(a2)+,d0				*
122					cmpi.b 		#'r',d0					* was the option 'r' found?
123					bne			usage
124
125	*
126	*		cancelling resident process
127	*
128	remove:			lea.l		myname(pc), a0			* is there any thread
129					lea.l		thinfo+thNAME(pc),a1	*  with the same name as mine?
130:cpylp:			move.b		(a0)+,(a1)+				*
131					bne			cpylp					*
132														*
133					pea.l		thinfo(pc)				*
134					move.w		#thNamed,-(sp)			*
135					DOS			_GET_PR					*
136	*				addq.l		#6,sp					*
137					tst.l		d0						*
138					bmi			rmerr1					* didn't
139					move.w		d0,d1					* d1 = Thread ID
140:				
141					pea.l		thinfo(pc)				* get your thread ID
142					move.w		#thMYSELF, -(sp)		*
143					DOS			_GET_PR					*
144					addq.l		#6,sp					* d0 = your thread ID
145					
146					clr.l		-(sp)					* wake up for now
147					clr.l		-(sp)					*
148					move.w		#thWAKEUP,-(sp)			*
149					move.w		d1,-(sp)				*
150:				move.w		d0,-(sp)				*
151					DOS			_SEND_PR				*
152					
153					move.w		#thKILL,4(sp)			* discard thread
154					moveq.l		#thBUSY,d2				* until a valid send
155					bra			send					*
156														*
157	sendlp:			DOS			_CHANGE_PR				*
158														*
159	send:			DOS			_SEND_PR				*
160:				cmp.l		d2,d0					*
161					beq			sendlp					*
162	*				lea.l		14(sp),sp				*
163
164					tst.l		d0						* adnormal event
165					bmi			rmerr2					*
166					
167					pea.l		thinfo(pc)				* confiming it's dead
168					move.w		d1,-(sp)				*
169	waitlp:			DOS			_CHANGE_PR				*
170:													*
171					DOS			_GET_PR					*
172					tst.l		d0						*
173					bpl			waitlp					*
174					addq.l		#6,sp					*
175
176					pea.l		remmes(pc)				* output release message
177					DOS			_PRINT					*
178					addq.l		#4,sp					*
179					
180:				DOS			_EXIT
181
182	*
183	*			Resident processing
184	*
185	keep:												* register background task
186					pea.l		1.w						* sleep time 1ms
187					pea.l		work+combuf(pc)			* inter-thread communication buffer
188					pea.l		bgent(pc)				* init PC (execution start address)
189					move.w		#thUSER,-(sp)			* init SR (user mode)
190:				pea.l		inissp(pc)				* init SSP
191					pea.l		iniusp(pc)				* INIT USP
192					move.w		#2,-(sp)				* execution priority (2 highest)
193					pea.l		myname(pc)				* thread name
194					DOS			_OPEN_PR				*
195	*				lea.l		28(sp),sp				*
196					tst.l		d0						*
197					bmi			kperr					* registration failed
198					
199					pea.l		keepms(pc)				* resdicent process also output
200:				DOS			_PRINT					*
201	*				addq.l		#4,sp					*
202
203					clr.w		-(sp)					* resident end
204					move.l		#KEEPSIZ,-(sp)			*
205					DOS			_KEEPPR					*
206
207	*
208	*			Error exit
209	*
210:kperr:			lea.l		errms1(pc),a0			* diplicate attempt to reside
211					moveq.l		#thCONFLICT,d1			*
212					cmp.l		d1, d0					*
213					beq			error
214					*
215					lea.l		errms2(pc),a0			* thread count limit
216					moveq.l		#thNOMORE,d1			*
217					cpm.l		d1,d0					*
218					beq			error					*
219					*
220:				lea.l		errms0(pc),a0			* process is not set
221					bra			error					*
222	*
223	rmerr1:			lea.l		errms3(pc),a0			* although it isn't resident
224					bra			error					* you tried to cancel it
225	*
226	rmerr2:			lea.l		errms4(pc),a0			* fail to cancel resident process
227					bra			error					*
228	*
229	vererr:			lea.l		verrms(pc),a0			* incorrect Human68k
230:				bra			error					* version
231	*
232	usage:			lea.l		usgmes(pc),a0			* show usage
233					*
234	error:			move.w		#STDERR,-(sp)			* print message 
235					pea.l		(a0)					* in stderr
236					DOS			_FPUTS					*
237	*				addq.l		#6.sp					*
238
239					move.w		#1,-(sp)				* error exit
240:				DOS			_EXIT2					*
241	*
242	myname:			.dc.b		'BGTEST',0				* my thread name
243	*
244	keepms			.dc.b		'BGTEST is now resident'，CR，LF，0
245	remmes: 		.dc.b		'BGTEST is not longer resident'，CR，LF，0
246	*
247	errms0: 		.dc.b		'CONFIG.SYSのPROCESSが'
248					.dc.b		'doesnt seem to be set' CR， LF， 0
249	errmsl: 		.dc.b		'BGTES is already resident', CR, LF， 0
250:errms2: 		.dc.b		'No more background processes', CR, LF, 0
251					.dc.b		'cant be started', CR, LF, 0
252	errms3: 		.dc.b		'BGTEST not built yet'，CR，LF，0
253	errms4: 		.dc.b		'BGTEST cannot be unresident'，CR， LF ，0
254	verrms:			.dc.b		'wrong Human68k version'，CR， LF， 0
255	*
256	usages:			.dc.b		'feature: background process test'，CR， LF
257					.dc.b		'BGTEST [/r]'，CR，LF
258					.dc.b		TAB，'./R' ，TAB， ' to exit'， CR，LF, 0
259	*
260:				.bss
261					.even
262	*
263	thinfo:			.ds.b		SIZEofTHREADINFO		* thread information storage area
264	*
265					.stack
266					.even
267	*
268					.ds.l		2048
269	inisp:
270:
271					.end		ent
────────────────────────────────────────────────────────────────────────────────────────────────────

Let's look at it from the non-resident department.
As per the rule of thumb for resident programs, the nonresident section begins on line 97 after the resident section.
Lines 100-102 confirm the version 1^01311681<. If you want to use the functions of Human68k ver 2.0, you have to make sure that the version number is 2.00 or later.
In addition to this, the sample program in the "Programmer's Manual" confirms that the version is less than 2.50, but the reason is not shown, and TIMER. It doesn't seem like it, so I've killed it in the comments here.
I would like you to revive it according to your taste.

Checks whether the /R option is specified on lines 106 to 123, and if not specified, jumps to resident processing on line 185.
Please note that the process of becoming resident is simpler than a normal resident program.
In order to prevent multiple resident programs in resident programs, it is necessary to check whether the same program as itself is already resident. In this case, if you try to register a task with the same thread name as a thread that already exists in open_pr, an error will be returned, so you can prevent multiple residency without paying special attention 131.

All that's left is to issue a resident message and exit resident.
However, in Listing 4, the danger zone is momentarily passed here.
If the execution is interrupted for some reason before returning from open_pr and resident termination, even though the thread was created, it will terminate without being resident, and it will definitely run away. will do.
Previously, when I made a resident program, I showed how to set the return address at the time of interruption and try again so that such a thing would not happen. It seems to be boring, so I defiantly ignore it.
Also, let's hope something doesn't fall on the keyboard at the wrong time and press the BREAK or COPY key.

Speaking of the dangerous area, in Listing 4, the stack of the resident part is overlapped with that of the non-resident part (lines 88-89). It becomes a form of running in the stack of the resident department.
Since it was made with great care, there will be no problems. When using the force f and list 4, please be careful about the size and positional relationship between the stack and the resident part.


Another thing I remembered in Stack. Background processing programs are supposed to reserve at least 6 Kbytes for the supervisor stack.
In practice, the user stack is added to this.
As shown in Listing 4, if the resident section stacks with the non-resident section, 6 Kbytes is enough for the non-resident section, including the space used for her stack.
Don't force it and put it away.
If it does, make the stack larger for the non-resident part (Listing 4 does too), and intentionally allocate more memory than the resident size.
Programs are given only the end of the stack section at startup, and there is no guarantee that there is still memory behind it. I don't know.
If you use equ to represent the end address of the resident part as in Listing 4, you may end up running out without realizing it, so be careful.

In the resident cancellation processing starting from line 128, a cancellation request is sent to the resident section, and the resident section commits suicide.
Like a general resident program, he doesn't need to take any steps when he frees the memory after finding out where the resident memory is.
First, on lines 128-139, he gets the thread ID of the thread to which the discard request was sent.
Normally, get_pr returns the management information of the thread specified by the thread ID. After that, if you specify 12 for the thread ID, get_pr will search for the thread corresponding to the thread name.
If Ella returns here, it means that he was not resident yet. Then, on lines 141-144, get her thread ID.
If 1 is specified as the thread ID, the thread management information and thread ID will be set to 5; II.


From line 146 onwards, we show a more correct picture of the inter-thread communication that we cut off earlier. Line 146~ sends a command to make it active for the time being, and wakes up the specified thread.
This takes into consideration the possibility that suspend_pr may be forced to sleep during communication using a program modified from List 3.
Then, on line 159, you actually send the discard request.
At this time, if an error code indicating that unprocessed communication data still remains in the communication node is returned, the request will continue to be sent until it is accepted.
Note that simply enclosing I: send— pr in a loop does not make much sense.
Each time you send it, you must relinquish the execution right with change_pr to give the resident section time to reset the inter-thread communication buffer.
Even if it's just looping, the power to switch threads someday?

If you can communicate successfully', or if send_pr returns an unexpected error code, then exit the loop and come to line 164.
If an error is returned, give up and exit with an error.
The recipient has already confirmed that the thread exists and has made it active, so if he comes back with a strange error code, it's quite an anomaly.
However, although it is a rare case, the possibility that the thread was destroyed after being activated at line 151 is not zero.
For example, if a destroy request had already been sent and was suspended with suspend —pr before it was processed, then activating it on line 151 will wake it up. commit suicide
It's a bit of a nitpick, but in an environment where multiple programs run concurrently, it's better for him to keep in mind that the information he got just a little while ago may not always be correct. deaf.

If the communication is successfully sent, the resident section receives it and confirms that it will self-destruct as requested.
As long as he can get the thread information with get_pr and get it successfully, the thread is still alive. Conversely, if get —pr returns an error, he will assume that the thread is dead.
Again, don't forget to call change_pr to give him time to kill himself.
In the "Programmer's Manual", there is a description that by calling change_pr and get_pr once, it is possible to determine whether the discard was successful or not. Since there is no guarantee that the execution right will be passed to all threads one by one until the next execution right ? I think it's right to tie it up.
In this case, if the discard request is ignored, it will fall into an infinite loop.
If your resident unit is designed to occasionally receive a discard request, set the number of repetitions, or exchange communications in advance to check whether it is ready to discard. It will happen sooner or later.


Please pay attention to the error processing routine (lines 210 to 240) in the non-resident part, especially the processing when open_pr returns an error when it is resident.
The possibilities for open_pr to fail are:

1) PROCESS in CONFIG.SYS is not set

2) The number of threads has already reached its limit

3) A thread with the same name exists

Force 5 ' is possible, so an error message is issued according to the error code.
It is the same as COMMAND.X if you cut corners and output an error message such as "PROCESS of CONFIG.SYS is not set, or the number of threads has reached the limit", or a thread with the same name exists. He is forced to level up and puts it away.

Let's have a look at the resident department from line 20.
Lines 21 to 30 are the initialization part.
First, in line 21, the top address of the work is put in a6 so that the work area can be accessed indirectly through the address register. Since this program uses almost no work, it would have been nice to simply refer to it with an absolute address. I tried to.
The work structure is defined on lines 8 to 13, and its substance is on lines 82 to 86.

Skipping one line, lines 25 to 30 set the processing address when interrupted by CTRL+C or a hardware error.
Without this setting, the processing address at the time of suspension remains the same as that of the resident processing. If you do, you run the risk of flying somewhere strange.
To avoid this, the background task must always set the processing address at the time of suspension 15).
In the skipped line 22, the stack pointer and work access registers are saved in preparation for recovery from interrupt processing to main processing.
Since the contents of the register are not guaranteed when control is passed to the interrupt processing routine, it must be reset (line 76).

Lines 32-69 are the main loop.
Processing inter-thread communication (lines 32-53), displaying one character (lines 55-64) and then sleeping for about 100 ms (66-68t7-). To determine whether communication has occurred, a method is adopted in which the inter-thread communication buffer is directly checked without using the return value of sleep-pr.

The processing part for inter-thread communication is a standard structure that subsists the thread's abort request and sleep request.
Lines 32 and 33 check whether there is communication, and if there is communication, fetch the command (line 36), and immediately reset the buffer to allow communication (line 38).
Here, originally, the buffer is reset after the communication processing is completed, but in this program, the size of the data area of the inter-thread communication buffer is set to 0 from the beginning. Therefore, no additional data other than the command is sent, and once the command is retrieved, there is no danger of information loss even if another communication is received by the communication processor.
After that, if a discard request is sent, it kills itself with kill_pr (line 44), and if a sleep request is sent, sleep forever with sleep-pr (lines 50 to 52).
The bra immediately after kil and pr, which is not supposed to come back, is insane.

As you can see, the one-character display unit sleeps for about 0.1 seconds and loops when it is read.
This sleeping part can change the time to sleep, relinquish execution with change_pr instead of sleeping, or sleep-- neither pr nor change or pr. If you change things such as jumping to the top of the norep instead of ', you may get a better understanding of background processing.


------    various DOS calls    ------ 

Finally, let's end with a list of other DOS calls related to pack grounding functions.

time_pr returns a 32-bit value counting the Int number of timer interrupts. If you call it at intervals, you can find the elapsed time in units of 1 ms from the difference in the return values.
When multiple programs are running in parallel, it becomes impossible to deal with time in a way that depends on the execution time of instructions, so another standard was set. and

s_malloc, s_free, and s_process make it possible to divide and allocate main memory, which has been treated only as a series so far, to each thread.
If this allocation is done in s_process as a thread, then future memory allocation requests from that thread will be limited to the allocated memory range.
This feature will be used to reserve memory for a background task that will allocate memory as needed with malloc.
When a program running in the foreground starts, it allocates the largest block of memory, so when a background task tries to allocate memory, there is no memory available. It is also possible.
Therefore, s_process cuts out the main memory in advance and allocates it exclusively for that thread.
, s_malloc and s_free allocate/free memory blocks for memory allocated unconditionally to the main thread.

malloc2 is a high-level call that improves the DOS call malloc so that the memory allocation method can be specified.
malloc unconditionally allocates memory from the lower address side, but by specifying the mode in malloc2, it allocates from the higher memory side (Mode 2), Or allocate memory (mode 1) from the free memory force; 5 I can.
A force not directly related to background processing?, might be useful in a batch program to move itself to the top of his memory in order to prevent memory fragmentation when making the program resident.

Then there are the Foreplay X files that exec now supports. Again, this is not just for back ground processing, and is reasonably useful if you have the resident and transient parts in separate X files.
An overlay X file here refers to multiple X files grouped together by BIND.X.
An overlay X file is simply a concatenation of X files with a module list appended to the end.
The location of the module list is stored in the first module's X-file header. For reference, the header 1# structure of the X file is shown in Table 2. If you're interested, dump the X-files at random and compare them. Here, I will only touch on the load mode of the 03 IIth item.

I didn't realize until relatively recently that setting the first bit of this byte would create a block of memory just large enough to fit from the text section to the stack section. is allocated from the higher address side of the , and the program will be loaded there. He in Human68k ver 2.0 is a minor enhancement.
This would be a useful feature for programs that have a resident portion high in memory. By the way, even if there is an option anyway, I tried it with LK.X now, and it seems that the /A option can be set to a single mode.
Specify the bit number you want to set immediately after /A. 0 through 7 are valid, but only 1 is present.

By the way, the 1st bit is somewhat ambiguous, but somehow the 0th bit also has a meaning, and if this bit is 1, memory is stored in a manner equivalent to malloc2 mode 1. It seems that he intended to allocate a It seems that this judgment part of Human68k is bugged and has lost its meaning.

*   *    *

Depending on how you use it, ground processing can be convenient and also fun (this is more important). The sharing of computer resources from multiple programs is a bit difficult, and there are constraints on the resources that are (or may be) available for knock-ground tasks. If you close your eyes to the points, you can also enjoy multitasking.

Even so, last time and this time, I pulled out a piece of undisclosed information from the analysis memo I had, but I felt quite pitiful halfway through that I was wasting my time on something very wasteful. rice field.
I want to use my time more meaningfully next year.

From the next time onwards, we will take up searching for strings.
Maybe next month I'll do a normal string search, and the month after next I'll be one step ahead of that, and maybe I'll spend one more time and go one step further. I won't be able to make it in time for next month.