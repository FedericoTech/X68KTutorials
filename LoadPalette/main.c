
#ifdef __MARIKO_CC__
#include <doslib.h>
#include <iocslib.h>
#else
#include <dos.h>
#include <iocs.h>
#endif

#include <stdint.h>

/**
  * In this example we are loading the palettes from the file palette.pal
  * The data is stored in binary format, in 16 bit words sequentially ordered.
  * Every palette is 32 bytes long.
  *
  * Then we make use of the function int _iocs_spalet (uint32_t code, uint8_t block, uint16_t color);
  *
  * The param code is a 32 bit word whose bit 31 is to set the Vertical Blanking Detection if 1
  * or not detection if 0
  * The bits 0 through 3 are the number of colour inside the palette which are 0 to 15
  * The macro SET_VBD_C is to ease
  *
  * The second param is the number of palette which are 1 to 15
  *
  * The third param is the color which is a 16 bit word to pick one of 65,536 colours
  */

#define VERTICAL_BLANKING_DETECTION 0x80000000     //0b10000000000000000000000000000000
#define VERTICAL_BLANKING_NO_DETECT 0

#define SET_VBD_V(vbd, v) (vbd | v)

int main(void)
{
    int8_t last_mode;
    int32_t status;
    //we will collect the palettes palette by palette in this array.


    last_mode = _iocs_crtmod(-1);

    status = _iocs_crtmod(8); //this mode is 512 x 512 256 colours

    /**
     * Loading the sprite/bg planes palette
     */
    {
        int8_t palette_num, colour_in_palete;
        uint16_t sp_colours[15][16] = {
            { 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF},
            { 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000},
            { 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000},
            { 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000},
            { 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000}
        };

        for(palette_num = 1; palette_num < 16; palette_num++){
            for(colour_in_palete = 0; colour_in_palete < 16; colour_in_palete++){
                //we set the colour
                status = _iocs_spalet(                  //returns 32 bit with the code of the colour just set or if colour is -1
                    SET_VBD_V(
                        VERTICAL_BLANKING_DETECTION,    //if 0 it waits for VBlank and it's slow
                        colour_in_palete                //0 - 15 if higher it only takes from 0-15
                    ),
                    palette_num,                        //1-15 or 0
                    sp_colours[palette_num -1][colour_in_palete]        // colour code, -1 to retrieve the code in that cell
                );

                //if any issue...
                if(status < 0){
                    switch(status){
                    case -1:
                        _dos_c_print("Incorrect screen mode\r\n");
                        break;
                    case -2:
                        _dos_c_print("attempting to set palette in block 0\r\n");
                        break;
                    }
                    _dos_exit2(status);
                }
            }
        }
    }

    /**
     * Loading the graphics palette
     */
    {
        uint8_t colour_in_palette;
        uint16_t g_colours[256] = {
            0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0x001D, 0x001D, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1,
            0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0x001D, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF,
            0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D,
            0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D,
            0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x07C1, 0xFFFF, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D,
            0x001D, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x07C1, 0xFFFF, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0x001D,
            0x001D, 0x001D, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0x07C1, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0x001D, 0x001D,
            0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x07C1, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
            0x07C1, 0x07C1, 0x07C1, 0x07C1, 0x07C1, 0x07C1, 0x07C1, 0x07C1, 0xFFFF, 0x07C1, 0x07C1, 0x07C1, 0x07C1, 0x07C1, 0x07C1, 0x07C1,
            0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0x07C1, 0xFFFF, 0x07C1, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF,
            0x001D, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0xFFFF, 0x07C1, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0x001D,
            0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0xFFFF, 0x07C1, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D,
            0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D,
            0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF, 0x001D,
            0xFFFF, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0x001D, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0x001D, 0xFFFF, 0x07C1, 0xFFFF,
            0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0x001D, 0x001D, 0x07C1, 0xFFFF, 0x001D, 0x001D, 0x001D, 0x001D, 0x001D, 0xFFFF, 0xFFFF
        };

        //we activate the graphic screen and display mode setting
        _iocs_g_clr_on();

        for(colour_in_palette = 0; colour_in_palette < 256; colour_in_palette++){
            status = _iocs_gpalet(                  //returns 32 bit with the code of the colour just set or if colour is -1
                colour_in_palette,                  //0 - 255
                g_colours[colour_in_palette]        // colour code, -1 to retrieve the code in that cell
            );

            //if any issue...
            if(status < 0){
                _dos_c_print("The graphic screen is not initialized \r\n");
            }
        }
    }

    /**
     * Restoring the text palette
     */
    {

        int8_t colour_in_palette;
        uint16_t t_colours[16] = {0x0000, 0x0000, 0x0000, 0xFFFF, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0xFFFF};

        for(colour_in_palette = 0; colour_in_palette < 4; colour_in_palette++){

            status =_iocs_tpalet(
                 colour_in_palette, //0, 1, 2 and 3 are independent colours, 4 -7 and 8 - 15 share the same colours.
                 t_colours[colour_in_palette]
             );

            //if any error...
            if(status < 0){
                _dos_c_print("Cant set the colour\r\n");
            }
        }
    }

    _dos_c_print("Look into the palette window of your emulator and press a key.\r\n");

    //waiting for a keystroke.
    _dos_getchar();

    /**
     * Restoring the text palette
     */
    {
        uint8_t colour_in_palette;
        //now we go through the current pallete
        for(colour_in_palette = 0; colour_in_palette < 4; colour_in_palette++){
            status =_iocs_tpalet(
                colour_in_palette, //0, 1, 2 and 3 are independent colours, 4 -7 and 8 - 15 share the same colours.
                -2  //returning the factory color
            );
        }

        status =_iocs_tpalet(
            4, //0, 1, 2 and 3 are independent colours, 4 -7 and 8 - 15 share the same colours.
            -2  //returning the factory color
        );

        status =_iocs_tpalet(
            8, //0, 1, 2 and 3 are independent colours, 4 -7 and 8 - 15 share the same colours.
            -2  //returning the factory color
        );
    }

    status = _iocs_crtmod(last_mode);

    _dos_exit();
}
